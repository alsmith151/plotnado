{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PlotNado","text":"<p>PlotNado is a python package designed to make quick genome browser style plots. The package is a wrapper around the coolbox library with some additional functionality and altered defaults to enable plotting muliple genomic regions with limited effort.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install PlotNado, you can use pip:</p> <pre><code>pip install git+https://github.com/alsmith151/plotnado\n\n# Once this is on pypi, you will be able to install it with:\n#pip install plotnado\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Basic plotting example notebook.</li> <li>Simple overlays of multiple tracks example notebook.</li> </ul>"},{"location":"basic_example/","title":"Basic Example:","text":"In\u00a0[14]: Copied! <pre>import seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotnado.api as pn\nimport numpy as np\n</pre> import seaborn as sns import matplotlib.pyplot as plt import plotnado.api as pn import numpy as np In\u00a0[2]: Copied! <pre>bigwigs = {\n    'MV4;11 0nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig',\n    'MV4;11 0.5nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV41105nMH3K79me2_bigWig.bigWig',\n    'MV4;11 2nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4112nMH3K79me2_bigWig.bigWig',\n    'MV4;11 5nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4115nMH3K79me2_bigWig.bigWig',\n}\n</pre> bigwigs = {     'MV4;11 0nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig',     'MV4;11 0.5nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV41105nMH3K79me2_bigWig.bigWig',     'MV4;11 2nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4112nMH3K79me2_bigWig.bigWig',     'MV4;11 5nM EPZ H3K79me2': 'https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4115nMH3K79me2_bigWig.bigWig', } In\u00a0[7]: Copied! <pre>figure = pn.Figure(autocolor=True, autospacing=True) # Create a figure instance, autocolor and autospacing are optional arguments but make the figure look nicer\nfigure.add_track('scale') # Add a scale track\nfigure.add_track('genes', genome='hg38', gene_style='normal', min_gene_length=1e5, height=0.5) # Add a gene track, this can specify a file in bed12 format or can be any supported genome name\n\n# Loop over the bigwigs and add them to the figure\nfor name, url in bigwigs.items():\n    figure.add_track('bigwig', # Track type \n                     file=url, # File or URL to the bigwig file \n                     title=name, # Title of the track \n                     style='stairsfilled', # Style of the track, can be 'line', 'fill', 'stairs', 'stairsfilled', 'hist', or None\n                     autoscale_group='H3K79me2', # (Optional) Autoscale group to scale the tracks together,\n                     min_value=0, # (Optional) Minimum value for the track\n                     )\n\nfigure.add_track('xaxis') # Add an x-axis track\n</pre> figure = pn.Figure(autocolor=True, autospacing=True) # Create a figure instance, autocolor and autospacing are optional arguments but make the figure look nicer figure.add_track('scale') # Add a scale track figure.add_track('genes', genome='hg38', gene_style='normal', min_gene_length=1e5, height=0.5) # Add a gene track, this can specify a file in bed12 format or can be any supported genome name  # Loop over the bigwigs and add them to the figure for name, url in bigwigs.items():     figure.add_track('bigwig', # Track type                       file=url, # File or URL to the bigwig file                       title=name, # Title of the track                       style='stairsfilled', # Style of the track, can be 'line', 'fill', 'stairs', 'stairsfilled', 'hist', or None                      autoscale_group='H3K79me2', # (Optional) Autoscale group to scale the tracks together,                      min_value=0, # (Optional) Minimum value for the track                      )  figure.add_track('xaxis') # Add an x-axis track In\u00a0[8]: Copied! <pre>region_to_plot = 'chr9:77,620,642-78,119,542' # Define the region to plot, this is a region around the GNAQ gene\ngene_to_plot = 'GNAQ' # Define the gene to plot, this is the GNAQ gene\n</pre> region_to_plot = 'chr9:77,620,642-78,119,542' # Define the region to plot, this is a region around the GNAQ gene gene_to_plot = 'GNAQ' # Define the gene to plot, this is the GNAQ gene In\u00a0[9]: Copied! <pre>figure.plot(region_to_plot) # Plot the region\n</pre> figure.plot(region_to_plot) # Plot the region <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 18:56:34.273 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[9]: In\u00a0[10]: Copied! <pre>figure.plot_gene('GNAQ', genome='hg38') # Plot the gene\n</pre> figure.plot_gene('GNAQ', genome='hg38') # Plot the gene <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 18:56:36.392 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[10]: In\u00a0[11]: Copied! <pre>figure.save(gr=region_to_plot, # The region to plot\n            output='GNAQ_H3K79me2.png', # The output file name, the file format is inferred from the extension\n            )\n</pre> figure.save(gr=region_to_plot, # The region to plot             output='GNAQ_H3K79me2.png', # The output file name, the file format is inferred from the extension             ) <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 18:58:45.692 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> In\u00a0[12]: Copied! <pre>figure.to_toml('H3K79me2.toml')\n</pre> figure.to_toml('H3K79me2.toml') In\u00a0[13]: Copied! <pre>new_figure = pn.Figure.from_toml('H3K79me2.toml')\nnew_figure.plot(region_to_plot)\n</pre> new_figure = pn.Figure.from_toml('H3K79me2.toml') new_figure.plot(region_to_plot) <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 19:05:49.114 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[13]: In\u00a0[25]: Copied! <pre>figure = pn.Figure(autospacing=True)\nfigure.add_track('scale')\nfigure.add_track('genes', \n                 genome='hg38', \n                 gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'\n                 min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot\n                 height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer\n                 )\n\n# Define the colours for the bigwigs\nbigwig_colours = {\n    'MV4;11 0nM EPZ H3K79me2': 'red',\n    'MV4;11 0.5nM EPZ H3K79me2': 'blue',\n    'MV4;11 2nM EPZ H3K79me2': 'green',\n    'MV4;11 5nM EPZ H3K79me2': 'purple',\n}\n\n# Loop over the bigwigs and add them to the figure\nfor name, url in bigwigs.items():\n    figure.add_track('bigwig', \n                     file=url, \n                     title=name, \n                     style='stairsfilled', \n                     color=bigwig_colours[name], # Set the colour of the track using the bigwig_colours dictionary\n                     autoscale_group='H3K79me2', \n                     min_value=0,\n                     data_range_style='text', # Display the data range as text rather than a bar\n                     )\n\nfigure.add_track('xaxis')\n\nfigure.plot_gene('GNAQ', genome='hg38')\n</pre> figure = pn.Figure(autospacing=True) figure.add_track('scale') figure.add_track('genes',                   genome='hg38',                   gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'                  min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot                  height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer                  )  # Define the colours for the bigwigs bigwig_colours = {     'MV4;11 0nM EPZ H3K79me2': 'red',     'MV4;11 0.5nM EPZ H3K79me2': 'blue',     'MV4;11 2nM EPZ H3K79me2': 'green',     'MV4;11 5nM EPZ H3K79me2': 'purple', }  # Loop over the bigwigs and add them to the figure for name, url in bigwigs.items():     figure.add_track('bigwig',                       file=url,                       title=name,                       style='stairsfilled',                       color=bigwig_colours[name], # Set the colour of the track using the bigwig_colours dictionary                      autoscale_group='H3K79me2',                       min_value=0,                      data_range_style='text', # Display the data range as text rather than a bar                      )  figure.add_track('xaxis')  figure.plot_gene('GNAQ', genome='hg38') <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 19:22:13.214 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[25]: In\u00a0[27]: Copied! <pre>figure = pn.Figure(autospacing=True)\nfigure.add_track('scale')\nfigure.add_track('genes', \n                 genome='hg38', \n                 gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'\n                 min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot\n                 height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer\n                 )\n\n# Define the colours for the bigwigs\nbigwig_colours = {\n    'MV4;11 0nM EPZ H3K79me2': 'red',\n    'MV4;11 0.5nM EPZ H3K79me2': 'blue',\n    'MV4;11 2nM EPZ H3K79me2': 'green',\n    'MV4;11 5nM EPZ H3K79me2': 'purple',\n}\n\nstyles = ['line', 'fill', 'stairs', 'stairsfilled']\n\nfor i, (name, url) in enumerate(bigwigs.items()): \n\n    style = styles[i]\n\n    figure.add_track('bigwig', \n                     file=url, \n                     title=f'{name} ({style})', \n                     style=style, \n                     color=bigwig_colours[name], # Set the colour of the track using the bigwig_colours dictionary\n                     autoscale_group='H3K79me2', \n                     min_value=0,\n                     data_range_style='text', # Display the data range as text rather than a bar\n                     )\n\nfigure.add_track('xaxis')\n\nfigure.plot_gene('GNAQ', genome='hg38')\n</pre> figure = pn.Figure(autospacing=True) figure.add_track('scale') figure.add_track('genes',                   genome='hg38',                   gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'                  min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot                  height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer                  )  # Define the colours for the bigwigs bigwig_colours = {     'MV4;11 0nM EPZ H3K79me2': 'red',     'MV4;11 0.5nM EPZ H3K79me2': 'blue',     'MV4;11 2nM EPZ H3K79me2': 'green',     'MV4;11 5nM EPZ H3K79me2': 'purple', }  styles = ['line', 'fill', 'stairs', 'stairsfilled']  for i, (name, url) in enumerate(bigwigs.items()):       style = styles[i]      figure.add_track('bigwig',                       file=url,                       title=f'{name} ({style})',                       style=style,                       color=bigwig_colours[name], # Set the colour of the track using the bigwig_colours dictionary                      autoscale_group='H3K79me2',                       min_value=0,                      data_range_style='text', # Display the data range as text rather than a bar                      )  figure.add_track('xaxis')  figure.plot_gene('GNAQ', genome='hg38') <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 19:24:37.297 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[27]: In\u00a0[30]: Copied! <pre>figure = pn.Figure(autospacing=True)\nfigure.add_track('scale')\nfigure.add_track('genes', \n                 genome='hg38', \n                 gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'\n                 min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot\n                 height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer\n                 )\n\n# Use the same bigwig but change the number of bins\nnumber_of_bins = [100, 500, 1000, 2000]\n\nfor nbins in number_of_bins:\n\n    figure.add_track('bigwig', \n                     file='https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig', \n                     title=f'MV4;11 0nM EPZ H3K79me2 ({nbins} bins)', \n                     style='line', \n                     color='red', \n                     autoscale_group='H3K79me2', \n                     min_value=0,\n                     data_range_style='text', \n                     number_of_bins=nbins, # Set the number of bins\n                     )\n\nfigure.add_track('xaxis')\nfigure.plot_gene('GNAQ', genome='hg38')\n</pre> figure = pn.Figure(autospacing=True) figure.add_track('scale') figure.add_track('genes',                   genome='hg38',                   gene_style='normal',  # 'normal' or 'flybase' - I much prefer 'normal'                  min_gene_length=1e5, # Minimum gene length to plot, useful to filter out small genes that often clutter the plot                  height=0.5, # Height of the track - setting this to 0.5 makes the gene track look nicer                  )  # Use the same bigwig but change the number of bins number_of_bins = [100, 500, 1000, 2000]  for nbins in number_of_bins:      figure.add_track('bigwig',                       file='https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig',                       title=f'MV4;11 0nM EPZ H3K79me2 ({nbins} bins)',                       style='line',                       color='red',                       autoscale_group='H3K79me2',                       min_value=0,                      data_range_style='text',                       number_of_bins=nbins, # Set the number of bins                      )  figure.add_track('xaxis') figure.plot_gene('GNAQ', genome='hg38') <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-05-29 19:28:38.591 | DEBUG    | plotnado.api.genes:plot_genes:174 - ylim 100,0\n</pre> Out[30]: In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"basic_example/#basic-example","title":"Basic Example:\u00b6","text":"<p>This is just a quick example of plotting a number of BigWig files using the package API</p>"},{"location":"basic_example/#imports","title":"Imports\u00b6","text":""},{"location":"basic_example/#define-the-bigwig-files-that-we-want-to-plot","title":"Define the BigWig files that we want to plot\u00b6","text":"<p>Note: The BigWig files are not included in the dataset, as it is possible to just use remote URLs to plot the data I'm going to use data stored on the CCB Oxford HPC.</p> <p>To make life easier I'm going to make a dictionary of the BigWig files that I want to plot. You could just add these one by one to the plot if you wanted to.</p>"},{"location":"basic_example/#generate-the-plot","title":"Generate the plot\u00b6","text":"<p>I'm going to make a basic plot with:</p> <ul> <li>scale bar</li> <li>gene annotations</li> <li>4 x BigWig files</li> <li>X-axis showing the chromosome coordinates</li> </ul>"},{"location":"basic_example/#display-the-plot","title":"Display the plot\u00b6","text":"<p>You've got multiple options for displaying the plot:</p> <ul> <li>Display it in a Jupyter notebook</li> <li>Save it to a file</li> <li>Save it as a template for later use or plotting using the CLI</li> </ul>"},{"location":"basic_example/#define-the-region-to-plot","title":"Define the region to plot\u00b6","text":"<p>There are two ways to define the region to plot:</p> <ol> <li>Use a set of genomic coordinates</li> <li>Use a gene name (this must be from a genome that is supported by the package)</li> </ol>"},{"location":"basic_example/#perform-the-plotting","title":"Perform the plotting\u00b6","text":""},{"location":"basic_example/#by-region","title":"By Region\u00b6","text":""},{"location":"basic_example/#by-gene","title":"By Gene\u00b6","text":""},{"location":"basic_example/#save-the-plot","title":"Save the plot\u00b6","text":""},{"location":"basic_example/#examine-the-saved-plot","title":"Examine the saved plot\u00b6","text":""},{"location":"basic_example/#save-the-plot-as-a-template","title":"Save the plot as a template\u00b6","text":"<p>This is useful if you want to use the same plot settings for multiple plots, it also allows you to edit the plot settings with standard text editors and then you can either use the PlotNado CLI to generate the plot or you can read in the template and plot it again using the API.</p>"},{"location":"basic_example/#examine-the-template","title":"Examine the template\u00b6","text":"<p>The tempate is a TOML file that contains all the settings for the plot, you can edit this file with a text editor and then use the PlotNado CLI to generate the plot.</p> <pre><code>{toml}\n[spacer]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[scale]\ntrack_type = \"scale\"\n\n[\"spacer 1\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[genes]\ntrack_type = \"genes\"\ngenome = \"hg38\"\ngene_style = \"normal\"\nmin_gene_length = 100000.0\nheight = 0.5\n\n[\"spacer 2\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[\"MV4;11 0nM EPZ H3K79me2\"]\ntrack_type = \"bigwig\"\nfile = \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig\"\ntitle = \"MV4;11 0nM EPZ H3K79me2\"\nstyle = \"stairsfilled\"\nautoscale_group = \"H3K79me2\"\nmin_value = 0\n\n[\"spacer 3\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[\"MV4;11 0.5nM EPZ H3K79me2\"]\ntrack_type = \"bigwig\"\nfile = \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV41105nMH3K79me2_bigWig.bigWig\"\ntitle = \"MV4;11 0.5nM EPZ H3K79me2\"\nstyle = \"stairsfilled\"\nautoscale_group = \"H3K79me2\"\nmin_value = 0\n\n[\"spacer 4\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[\"MV4;11 2nM EPZ H3K79me2\"]\ntrack_type = \"bigwig\"\nfile = \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4112nMH3K79me2_bigWig.bigWig\"\ntitle = \"MV4;11 2nM EPZ H3K79me2\"\nstyle = \"stairsfilled\"\nautoscale_group = \"H3K79me2\"\nmin_value = 0\n\n[\"spacer 5\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[\"MV4;11 5nM EPZ H3K79me2\"]\ntrack_type = \"bigwig\"\nfile = \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4115nMH3K79me2_bigWig.bigWig\"\ntitle = \"MV4;11 5nM EPZ H3K79me2\"\nstyle = \"stairsfilled\"\nautoscale_group = \"H3K79me2\"\nmin_value = 0\n\n[\"spacer 6\"]\ntrack_type = \"spacer\"\nheight = 0.1\n\n[xaxis]\ntrack_type = \"xaxis\"\n</code></pre>"},{"location":"basic_example/#re-load-the-template-and-plot-it","title":"Re-load the template and plot it\u00b6","text":"<p>Note: In the original plot I took advantage of the 'autocolor' feature of the package, this will automatically assign a color to each track, these colors are not saved in the template. You can either add them manually or you can use the 'autocolor' option again when you load the template.</p>"},{"location":"basic_example/#cli-replotting","title":"CLI replotting\u00b6","text":"<p>You can use the CLI to replot the template, this is useful if you want to make a number of plots with the same settings.</p>"},{"location":"basic_example/#customizing-the-plot","title":"Customizing the plot\u00b6","text":"<p>While it's possible to customize the figure after it's been generated, it's far easier to customize the tracks while you are adding them to the figure. Alternatively, you can save the plot as a template and then edit the template file with a text editor.</p> <p>I'm going to run through a few examples of customizing the plot:</p> <ol> <li>Changing the color of the tracks</li> <li>Changing the y-axis style</li> <li>Changing the style of the BigWig tracks</li> </ol>"},{"location":"basic_example/#changing-the-style-of-the-bigwig-tracks","title":"Changing the style of the BigWig tracks\u00b6","text":""},{"location":"basic_example/#changing-the-number-of-bins","title":"Changing the number of bins\u00b6","text":"<p>Incrases or decreases the amount of noise in the plot. A lower number of bins will make the plot smoother, but you may lose some detail whereas a higher number of bins will give you more detail but the plot will be noisier.</p>"},{"location":"gen_ref_pages/","title":"Gen ref pages","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages.\"\"\"\n</pre> \"\"\"Generate the code reference pages.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\n</pre> nav = mkdocs_gen_files.Nav() In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(\"plotnado/api\").glob(\"*.py\")):  #\n\n    module_path = path.relative_to(\".\").with_suffix(\"\")  #\n    doc_path = module_path.with_suffix(\".md\")  #\n    full_doc_path = Path(\"reference\", doc_path)  #\n\n    parts = list(module_path.parts)\n\n    if module_path.stem == \"__init__\":\n        continue\n    elif parts[-1] == \"__init__\":  #\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    nav[parts] = doc_path.as_posix()  #\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:  #\n        identifier = \".\".join(parts)  #\n        print(\"::: \" + identifier, file=fd)  #\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)  #\n</pre> for path in sorted(Path(\"plotnado/api\").glob(\"*.py\")):  #      module_path = path.relative_to(\".\").with_suffix(\"\")  #     doc_path = module_path.with_suffix(\".md\")  #     full_doc_path = Path(\"reference\", doc_path)  #      parts = list(module_path.parts)      if module_path.stem == \"__init__\":         continue     elif parts[-1] == \"__init__\":  #         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      nav[parts] = doc_path.as_posix()  #      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:  #         identifier = \".\".join(parts)  #         print(\"::: \" + identifier, file=fd)  #      mkdocs_gen_files.set_edit_path(full_doc_path, path)  # In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:  #\n    nav_file.writelines(nav.build_literate_nav())  #\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.md\", \"w\") as nav_file:  #     nav_file.writelines(nav.build_literate_nav())  #"},{"location":"simple_overlays/","title":"Overlays Example:","text":"In\u00a0[1]: Copied! <pre>import seaborn as sns\nimport matplotlib.pyplot as plt\nimport plotnado.api as pn\nfrom plotnado.api import TrackWrapper\nimport numpy as np\n</pre> import seaborn as sns import matplotlib.pyplot as plt import plotnado.api as pn from plotnado.api import TrackWrapper import numpy as np In\u00a0[2]: Copied! <pre>bigwigs = {\n    \"MV4;11 0nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig\",\n    \"MV4;11 0.5nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV41105nMH3K79me2_bigWig.bigWig\",\n    \"MV4;11 2nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4112nMH3K79me2_bigWig.bigWig\",\n    \"MV4;11 5nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4115nMH3K79me2_bigWig.bigWig\",\n}\n</pre> bigwigs = {     \"MV4;11 0nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4110nMH3K79me2_bigWig.bigWig\",     \"MV4;11 0.5nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV41105nMH3K79me2_bigWig.bigWig\",     \"MV4;11 2nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4112nMH3K79me2_bigWig.bigWig\",     \"MV4;11 5nM EPZ H3K79me2\": \"https://userweb.molbiol.ox.ac.uk/public/project/milne_group/cchahrou/orlando_chip/hg38_dm6/MV4115nMH3K79me2_bigWig.bigWig\", } In\u00a0[19]: Copied! <pre>figure = pn.Figure()\nfigure.add_track(\"scale\")  # Add a scale track\nfigure.add_track(\n    \"genes\", genome=\"hg38\", gene_style=\"normal\", min_gene_length=1e5, height=0.5\n)  # Add a gene track, this can specify a file in bed12 format or can be any supported genome name\n\n# Create the bigwig tracks using the TrackWrapper class. This is a simplified wrapper that the add_tracks method uses internally.\ntracks_for_figure = []\ncolors = sns.color_palette(\"husl\", len(bigwigs))\n\nfor (name, url), color in zip(bigwigs.items(), colors):\n    # Create a track for each bigwig file\n    track = TrackWrapper(\n        \"bigwig\",\n        file=url,\n        title=name,\n        style=\"stairsfilled\",\n        color=color,\n        alpha=0.5, # Set the transparency of the track\n        autoscale_group=\"h3k79me3\", # Autoscale the tracks in the same group, this can be any identifier that you want\n        data_range_style='text', # Show the data range as text rather than a bar\n    )\n\n    # For illustration purposes I will add the track to the figure here, but this is not necessary\n    figure.add_track(track)\n\n    # Add the track to the list of tracks to be overlayed\n    tracks_for_figure.append(track)\n\n# Create an overlay track\noverlay_track = TrackWrapper(\"bigwig_overlay\", tracks_for_figure)\n\n# Add the overlay track to the figure\nfigure.add_track(overlay_track)\n\n# Add an x-axis track\nfigure.add_track(\"xaxis\")\n</pre> figure = pn.Figure() figure.add_track(\"scale\")  # Add a scale track figure.add_track(     \"genes\", genome=\"hg38\", gene_style=\"normal\", min_gene_length=1e5, height=0.5 )  # Add a gene track, this can specify a file in bed12 format or can be any supported genome name  # Create the bigwig tracks using the TrackWrapper class. This is a simplified wrapper that the add_tracks method uses internally. tracks_for_figure = [] colors = sns.color_palette(\"husl\", len(bigwigs))  for (name, url), color in zip(bigwigs.items(), colors):     # Create a track for each bigwig file     track = TrackWrapper(         \"bigwig\",         file=url,         title=name,         style=\"stairsfilled\",         color=color,         alpha=0.5, # Set the transparency of the track         autoscale_group=\"h3k79me3\", # Autoscale the tracks in the same group, this can be any identifier that you want         data_range_style='text', # Show the data range as text rather than a bar     )      # For illustration purposes I will add the track to the figure here, but this is not necessary     figure.add_track(track)      # Add the track to the list of tracks to be overlayed     tracks_for_figure.append(track)  # Create an overlay track overlay_track = TrackWrapper(\"bigwig_overlay\", tracks_for_figure)  # Add the overlay track to the figure figure.add_track(overlay_track)  # Add an x-axis track figure.add_track(\"xaxis\") In\u00a0[20]: Copied! <pre>figure.plot_gene(\"GNAQ\", \"hg38\")\n</pre> figure.plot_gene(\"GNAQ\", \"hg38\") <pre>[W::hts_idx_load3] The index file is older than the data file: /ceph/project/milne_group/asmith/software/mambaforge/envs/plotnado/lib/python3.12/site-packages/plotnado/data/gene_bed_files/hg38_genes.bed.bgz.tbi\n2024-07-02 15:34:00.494 | DEBUG    | plotnado.api.genes:plot_genes:176 - ylim 100,0\n</pre> Out[20]:"},{"location":"simple_overlays/#overlays-example","title":"Overlays Example:\u00b6","text":"<p>This is just a quick example of plotting a number of BigWig files using the package API</p>"},{"location":"simple_overlays/#imports","title":"Imports\u00b6","text":""},{"location":"simple_overlays/#define-the-bigwig-files-that-we-want-to-plot","title":"Define the BigWig files that we want to plot\u00b6","text":"<p>Note: The BigWig files are not included in the dataset, as it is possible to just use remote URLs to plot the data I'm going to use data stored on the CCB Oxford HPC.</p> <p>To make life easier I'm going to make a dictionary of the BigWig files that I want to plot. You could just add these one by one to the plot if you wanted to.</p>"},{"location":"simple_overlays/#generate-the-plot","title":"Generate the plot\u00b6","text":""},{"location":"simple_overlays/#display-the-plot","title":"Display the plot\u00b6","text":""},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>plotnado<ul> <li>api<ul> <li>figure</li> <li>genes</li> <li>patches</li> <li>track_wrapper</li> <li>tracks</li> <li>utils</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/plotnado/api/figure/","title":"Figure","text":""},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure","title":"<code>Figure</code>","text":"<p>Generates a figure from a list of tracks</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>List[TrackWrapper]</code> <p>List of tracks to plot. Defaults to None.</p> <code>None</code> <code>auto_spacing</code> <code>bool</code> <p>Automatically add a spacer track between each track. Defaults to False.</p> required <code>frame_args</code> <code>Dict[str, Any]</code> <p>Arguments to pass to the frame. Defaults to None.</p> <code>None</code> <code>autoscale_groups</code> <code>Dict[str, List[int]]</code> <p>Groups of tracks to autoscale together. Defaults to None.</p> required <code>**kwargs</code> <p>Additional arguments to pass to the figure</p> <code>{}</code> Source code in <code>plotnado/api/figure.py</code> <pre><code>class Figure:\n    \"\"\"\n    Generates a figure from a list of tracks\n\n    Args:\n        tracks (List[TrackWrapper], optional): List of tracks to plot. Defaults to None.\n        auto_spacing (bool, optional): Automatically add a spacer track between each track. Defaults to False.\n        frame_args (Dict[str, Any], optional): Arguments to pass to the frame. Defaults to None.\n        autoscale_groups (Dict[str, List[int]], optional): Groups of tracks to autoscale together. Defaults to None.\n        **kwargs: Additional arguments to pass to the figure\n    \"\"\"\n\n    def __init__(\n        self,\n        tracks: List[TrackWrapper] = None,\n        autospacing: bool = False,\n        autospacing_height: float = 0.1,\n        frame_args: Dict[str, Any] = None,\n        highlight_regions: Union[pathlib.Path, cb.HighLights] = None,\n        highlight_regions_color: str = \"blue\",\n        highlight_regions_kwargs: Dict[str, Any] = None,\n        autocolor: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        self.frame = cb.Frame(**frame_args if frame_args else dict())\n        self.autospacing = autospacing\n        self.autospacing_height = autospacing_height\n        self.autocolor = autocolor\n        self.properties = dict()\n        self.properties.update(kwargs)\n\n        self.tracks = OrderedDict()\n        if tracks:\n            self.add_tracks(tracks)\n\n        if isinstance(highlight_regions, (pathlib.Path, str)):\n            self.highlight_regions = HighlightsFromFile(\n                highlight_regions,\n                color=highlight_regions_color,\n                **highlight_regions_kwargs if highlight_regions_kwargs else dict(),\n            )\n        else:\n            self.highlight_regions = highlight_regions\n\n        self.track_name_to_frame_name_mapping = dict()\n\n    def add_track(self, track: Union[str, TrackWrapper], **kwargs) -&gt; None:\n        \"\"\"\n        Add a track to the figure\n\n        Args:\n            track (TrackWrapper): Track to add\n        \"\"\"\n\n        if isinstance(track, str):\n            track = TrackWrapper(track_type=track, **kwargs)\n\n        # Add a spacer track if auto_spacing is enabled\n        if self.autospacing:\n            spacer = TrackWrapper(track_type=\"spacer\", height=self.autospacing_height)\n            title = get_track_title(spacer, self.tracks)\n            self.tracks[title] = spacer\n\n        # Get the title of the track\n        title = get_track_title(track, self.tracks)\n\n        # Add the track to the collection\n        self.tracks[title] = track\n\n        # Add the track to the frame so coolbox can plot its\n        self.frame.add_track(track.track)\n\n        # Add the track to the mapping (take the last track added to the frame as the frame name)\n        self.track_name_to_frame_name_mapping[title] = list(self.frame.tracks.keys())[\n            -1\n        ]\n\n    def add_tracks(self, tracks: List[TrackWrapper]) -&gt; None:\n        \"\"\"\n        Add a list of tracks to the figure\n\n        Args:\n            tracks (List[TrackWrapper]): List of tracks to add\n        \"\"\"\n        for track in tracks:\n            self.add_track(track)\n\n    def _autoscale(self, gr: cb.GenomeRange, gr2: cb.GenomeRange = None):\n        # Extract the autoscale groups\n        scale_groups = defaultdict(list)\n        for title, track in self.tracks.items():\n            if track.autoscale_group:\n                scale_groups[track.autoscale_group].append(title)\n\n        # Autoscale the tracks\n        for group, tracks in scale_groups.items():\n            # Need to translate the track names to the frame names\n            tracks = [self.track_name_to_frame_name_mapping[title] for title in tracks]\n            autoscaler = Autoscaler(\n                [self.frame.tracks[title] for title in tracks],\n                gr,\n                gr2,\n            )\n\n            max_value = autoscaler.max_value\n            min_value = autoscaler.min_value\n\n            for title in tracks:\n                self.frame.tracks[title].properties[\"max_value\"] = max_value\n                self.frame.tracks[title].properties[\"min_value\"] = min_value\n\n    def _autocolor(self):\n        colors = list(plt.cm.tab20.colors)\n        tracktypes_for_autocolor = [\"bigwig\"]\n\n        for track_name, track in self.frame.tracks.items():\n            if any(y in track_name.lower() for y in tracktypes_for_autocolor):\n                color_number = np.random.choice(range(len(colors)))\n                color = colors[color_number]\n                track.properties[\"color\"] = color\n\n    @property\n    def data_tracks(self):\n        tracks = OrderedDict()\n        for title, track in self.tracks.items():\n            if not any(y in title for y in [\"spacer\"]):\n                tracks[title] = track\n        return tracks\n\n    def plot(\n        self,\n        gr: Union[str, cb.GenomeRange],\n        gr2: Union[str, cb.GenomeRange] = None,\n        show: bool = True,\n        extend: Union[int, Dict[Literal[\"upstream\", \"downstream\"], int]] = 0,\n        **kwargs,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"\n        Plot the figure\n\n        Args:\n            gr (Union[str, GenomeRange]): GenomeRange to plot\n            gr2 (Union[str, GenomeRange], optional): Second GenomeRange to plot. Defaults to None.\n            show (bool, optional): Show the figure. Defaults to True.\n            **kwargs: Additional arguments to pass to the plot\n\n        Returns:\n            matplotlib.figure.Figure: The figure\n        \"\"\"\n\n        # Ensure the genome ranges are valid\n        if isinstance(gr, str):\n            gr = cb.GenomeRange(gr)\n\n        if isinstance(gr2, str):\n            gr2 = cb.GenomeRange(gr2)\n\n        # Extend the genome ranges\n        if isinstance(extend, int):\n            extend = {\"upstream\": extend, \"downstream\": extend}\n\n        gr.start = max(0, gr.start - extend[\"upstream\"])\n        gr.end = gr.end + extend[\"downstream\"]\n\n        if gr2:\n            gr2.start = max(0, gr2.start - extend[\"upstream\"])\n            gr2.end = gr2.end + extend[\"downstream\"]\n\n        # Autoscale the tracks\n        self._autoscale(gr, gr2)\n\n        # Autocolor the tracks if specified\n        if self.autocolor:\n            self._autocolor()\n\n        # Highlight the regions if specified\n        if self.highlight_regions:\n            self.frame = self.frame * self.highlight_regions\n\n        # Patch the frame plot method to allow for label location\n        import functools\n\n        self.frame.plot = functools.partial(_plot, self.frame)\n\n        # Plot the figure as 2D or 1D depending on the number of genome ranges\n        if gr2:\n            fig = self.frame.plot(gr, gr2, **kwargs)\n        else:\n            fig = self.frame.plot(gr, **kwargs)\n        if show:\n            fig.show()\n\n        return fig\n\n    def plot_gene(\n        self,\n        gene: str,\n        genome: str,\n        **kwargs,\n    ):\n        \"\"\"\n        Plot the figure for a gene\n\n        Args:\n            gene (str): Gene to plot\n            genome (str): Genome for the gene. Can be a genome name or a path to a json file containing coordinates\n            **kwargs: Additional arguments to pass to the plot\n        \"\"\"\n        import importlib\n        import json\n\n        try:\n            genes_prefix = importlib.resources.files(\"plotnado.data.genes\")\n            with open(genes_prefix / f\"{genome}.json\") as f:\n                genes = json.load(f)\n        except (ModuleNotFoundError, FileNotFoundError):\n            try:\n                with open(genome, 'r') as f:\n                    genes = json.load(f)\n            except FileNotFoundError:\n                print(\"Genome not found\")\n                raise RuntimeError(\"Genome not found\")\n\n        gene = genes[gene]\n        gr = cb.GenomeRange(gene[\"chrom\"], gene[\"start\"], gene[\"end\"])\n        return self.plot(gr, **kwargs)\n\n    def plot_regions(\n        self,\n        regions: Union[\n            pathlib.Path, pr.PyRanges, pd.DataFrame, Dict[str, cb.GenomeRange]\n        ],\n        show: bool = True,\n        **kwargs,\n    ) -&gt; Dict[str, matplotlib.figure.Figure]:\n        \"\"\"\n        Plot the figure for a list of regions\n\n        Args:\n            regions (Union[str, pd.DataFrame, List[GenomeRange]]): Regions to plot\n            show (bool, optional): Show the figure. Defaults to True.\n            **kwargs: Additional arguments to pass to the plot\n\n        Returns:\n            Dict[str, matplotlib.figure.Figure]: Dictionary of figures for each region\n        \"\"\"\n\n        # Format the regions into a dictionary of genome ranges\n        if isinstance(regions, pathlib.Path):\n            regions = pr.read_bed(str(regions))\n\n        if isinstance(regions, pr.PyRanges):\n            regions = {\n                (\n                    row.Name if row.Name else f\"{row.Chromosome}_{row.Start}_{row.End}\"\n                ): cb.GenomeRange(\n                    chrom=row.Chromosome,\n                    start=row.Start,\n                    end=row.End,\n                )\n                for _, row in regions.df.itertuples()\n            }\n\n        if isinstance(regions, pd.DataFrame):\n            assert (\n                \"Chromosome\" in regions.columns\n            ), \"Chromosome column not found in regions\"\n            assert \"Start\" in regions.columns, \"Start column not found in regions\"\n            assert \"End\" in regions.columns, \"End column not found in regions\"\n\n            regions = {\n                (\n                    row.Name if row.Name else f\"{row.Chromosome}_{row.Start}_{row.End}\"\n                ): cb.GenomeRange(\n                    chrom=row.Chromosome,\n                    start=row.Start,\n                    end=row.End,\n                )\n                for _, row in regions.iterrows()\n            }\n\n        plots = dict()\n        for name, gr in regions.items():\n            plots[name] = self.plot(gr, show=False, **kwargs)\n\n        return plots\n\n    def save(\n        self,\n        gr: Union[str, cb.GenomeRange],\n        gr2: Union[str, cb.GenomeRange] = None,\n        output: str = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        Plots the figure and saves it to a file\n\n        Args:\n            gr (Union[str, GenomeRange]): GenomeRange to plot\n            gr2 (Union[str, GenomeRange], optional): Second GenomeRange to plot. Defaults to None.\n            output (str, optional): Path to save the figure to. Defaults to None.\n            **kwargs: Additional arguments to pass to the plot\n        \"\"\"\n\n        fig = self.plot(gr, gr2, show=False, **kwargs)\n        if output:\n            fig.savefig(output, dpi=300, bbox_inches=\"tight\")\n        else:\n            fig.savefig(f\"{gr.chrom}_{gr.start}_{gr.end}.png\", dpi=300, bbox_inches=\"tight\")\n\n    @classmethod\n    def from_toml(cls, toml_file: os.PathLike, **kwargs) -&gt; \"Figure\":\n        \"\"\"\n        Instantiate a Figure from a toml file\n\n        Args:\n            toml_file (os.PathLike): Path to toml file\n            **kwargs: Additional arguments to pass to the figure\n        \"\"\"\n        import toml\n\n        with open(toml_file) as f:\n            config = toml.load(f)\n\n        _cls = cls()\n        for track_name, track_properties in config.items():\n            _cls.add_track(TrackWrapper.from_dict(track_properties))\n\n        return _cls\n\n    def to_toml(self, output: str = None) -&gt; Union[None, Dict[str, Any]]:\n        \"\"\"\n        Save the Figure to a toml file\n\n        Args:\n            output (str, optional): Path to save the toml file to. Defaults to None.\n\n        Returns:\n            Union[None, Dict[str, Any]]: If output is not specified, returns a dict of the toml file\n\n        \"\"\"\n\n        from collections import OrderedDict\n\n        import toml\n\n        # Ordered dict with the key being a unique identifier for the track\n        # ideally the title of the track or the track type with a number to ensure uniqueness\n        config = OrderedDict()\n        for title, track in self.tracks.items():\n            config[title] = track.to_dict()\n\n        outfile = output if output else \"config.toml\"\n\n        with open(outfile, \"w\") as f:\n            config_str = toml.dumps(config)\n            f.write(config_str)\n\n        if not output:\n            return config\n\n    def __repr__(self) -&gt; str:\n        return f\"Figure({len(self.tracks)} tracks)\"\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.add_track","title":"<code>add_track(track, **kwargs)</code>","text":"<p>Add a track to the figure</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackWrapper</code> <p>Track to add</p> required Source code in <code>plotnado/api/figure.py</code> <pre><code>def add_track(self, track: Union[str, TrackWrapper], **kwargs) -&gt; None:\n    \"\"\"\n    Add a track to the figure\n\n    Args:\n        track (TrackWrapper): Track to add\n    \"\"\"\n\n    if isinstance(track, str):\n        track = TrackWrapper(track_type=track, **kwargs)\n\n    # Add a spacer track if auto_spacing is enabled\n    if self.autospacing:\n        spacer = TrackWrapper(track_type=\"spacer\", height=self.autospacing_height)\n        title = get_track_title(spacer, self.tracks)\n        self.tracks[title] = spacer\n\n    # Get the title of the track\n    title = get_track_title(track, self.tracks)\n\n    # Add the track to the collection\n    self.tracks[title] = track\n\n    # Add the track to the frame so coolbox can plot its\n    self.frame.add_track(track.track)\n\n    # Add the track to the mapping (take the last track added to the frame as the frame name)\n    self.track_name_to_frame_name_mapping[title] = list(self.frame.tracks.keys())[\n        -1\n    ]\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.add_tracks","title":"<code>add_tracks(tracks)</code>","text":"<p>Add a list of tracks to the figure</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>List[TrackWrapper]</code> <p>List of tracks to add</p> required Source code in <code>plotnado/api/figure.py</code> <pre><code>def add_tracks(self, tracks: List[TrackWrapper]) -&gt; None:\n    \"\"\"\n    Add a list of tracks to the figure\n\n    Args:\n        tracks (List[TrackWrapper]): List of tracks to add\n    \"\"\"\n    for track in tracks:\n        self.add_track(track)\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.from_toml","title":"<code>from_toml(toml_file, **kwargs)</code>  <code>classmethod</code>","text":"<p>Instantiate a Figure from a toml file</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>PathLike</code> <p>Path to toml file</p> required <code>**kwargs</code> <p>Additional arguments to pass to the figure</p> <code>{}</code> Source code in <code>plotnado/api/figure.py</code> <pre><code>@classmethod\ndef from_toml(cls, toml_file: os.PathLike, **kwargs) -&gt; \"Figure\":\n    \"\"\"\n    Instantiate a Figure from a toml file\n\n    Args:\n        toml_file (os.PathLike): Path to toml file\n        **kwargs: Additional arguments to pass to the figure\n    \"\"\"\n    import toml\n\n    with open(toml_file) as f:\n        config = toml.load(f)\n\n    _cls = cls()\n    for track_name, track_properties in config.items():\n        _cls.add_track(TrackWrapper.from_dict(track_properties))\n\n    return _cls\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.plot","title":"<code>plot(gr, gr2=None, show=True, extend=0, **kwargs)</code>","text":"<p>Plot the figure</p> <p>Parameters:</p> Name Type Description Default <code>gr</code> <code>Union[str, GenomeRange]</code> <p>GenomeRange to plot</p> required <code>gr2</code> <code>Union[str, GenomeRange]</code> <p>Second GenomeRange to plot. Defaults to None.</p> <code>None</code> <code>show</code> <code>bool</code> <p>Show the figure. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>matplotlib.figure.Figure: The figure</p> Source code in <code>plotnado/api/figure.py</code> <pre><code>def plot(\n    self,\n    gr: Union[str, cb.GenomeRange],\n    gr2: Union[str, cb.GenomeRange] = None,\n    show: bool = True,\n    extend: Union[int, Dict[Literal[\"upstream\", \"downstream\"], int]] = 0,\n    **kwargs,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"\n    Plot the figure\n\n    Args:\n        gr (Union[str, GenomeRange]): GenomeRange to plot\n        gr2 (Union[str, GenomeRange], optional): Second GenomeRange to plot. Defaults to None.\n        show (bool, optional): Show the figure. Defaults to True.\n        **kwargs: Additional arguments to pass to the plot\n\n    Returns:\n        matplotlib.figure.Figure: The figure\n    \"\"\"\n\n    # Ensure the genome ranges are valid\n    if isinstance(gr, str):\n        gr = cb.GenomeRange(gr)\n\n    if isinstance(gr2, str):\n        gr2 = cb.GenomeRange(gr2)\n\n    # Extend the genome ranges\n    if isinstance(extend, int):\n        extend = {\"upstream\": extend, \"downstream\": extend}\n\n    gr.start = max(0, gr.start - extend[\"upstream\"])\n    gr.end = gr.end + extend[\"downstream\"]\n\n    if gr2:\n        gr2.start = max(0, gr2.start - extend[\"upstream\"])\n        gr2.end = gr2.end + extend[\"downstream\"]\n\n    # Autoscale the tracks\n    self._autoscale(gr, gr2)\n\n    # Autocolor the tracks if specified\n    if self.autocolor:\n        self._autocolor()\n\n    # Highlight the regions if specified\n    if self.highlight_regions:\n        self.frame = self.frame * self.highlight_regions\n\n    # Patch the frame plot method to allow for label location\n    import functools\n\n    self.frame.plot = functools.partial(_plot, self.frame)\n\n    # Plot the figure as 2D or 1D depending on the number of genome ranges\n    if gr2:\n        fig = self.frame.plot(gr, gr2, **kwargs)\n    else:\n        fig = self.frame.plot(gr, **kwargs)\n    if show:\n        fig.show()\n\n    return fig\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.plot_gene","title":"<code>plot_gene(gene, genome, **kwargs)</code>","text":"<p>Plot the figure for a gene</p> <p>Parameters:</p> Name Type Description Default <code>gene</code> <code>str</code> <p>Gene to plot</p> required <code>genome</code> <code>str</code> <p>Genome for the gene. Can be a genome name or a path to a json file containing coordinates</p> required <code>**kwargs</code> <p>Additional arguments to pass to the plot</p> <code>{}</code> Source code in <code>plotnado/api/figure.py</code> <pre><code>def plot_gene(\n    self,\n    gene: str,\n    genome: str,\n    **kwargs,\n):\n    \"\"\"\n    Plot the figure for a gene\n\n    Args:\n        gene (str): Gene to plot\n        genome (str): Genome for the gene. Can be a genome name or a path to a json file containing coordinates\n        **kwargs: Additional arguments to pass to the plot\n    \"\"\"\n    import importlib\n    import json\n\n    try:\n        genes_prefix = importlib.resources.files(\"plotnado.data.genes\")\n        with open(genes_prefix / f\"{genome}.json\") as f:\n            genes = json.load(f)\n    except (ModuleNotFoundError, FileNotFoundError):\n        try:\n            with open(genome, 'r') as f:\n                genes = json.load(f)\n        except FileNotFoundError:\n            print(\"Genome not found\")\n            raise RuntimeError(\"Genome not found\")\n\n    gene = genes[gene]\n    gr = cb.GenomeRange(gene[\"chrom\"], gene[\"start\"], gene[\"end\"])\n    return self.plot(gr, **kwargs)\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.plot_regions","title":"<code>plot_regions(regions, show=True, **kwargs)</code>","text":"<p>Plot the figure for a list of regions</p> <p>Parameters:</p> Name Type Description Default <code>regions</code> <code>Union[str, DataFrame, List[GenomeRange]]</code> <p>Regions to plot</p> required <code>show</code> <code>bool</code> <p>Show the figure. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional arguments to pass to the plot</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Figure]</code> <p>Dict[str, matplotlib.figure.Figure]: Dictionary of figures for each region</p> Source code in <code>plotnado/api/figure.py</code> <pre><code>def plot_regions(\n    self,\n    regions: Union[\n        pathlib.Path, pr.PyRanges, pd.DataFrame, Dict[str, cb.GenomeRange]\n    ],\n    show: bool = True,\n    **kwargs,\n) -&gt; Dict[str, matplotlib.figure.Figure]:\n    \"\"\"\n    Plot the figure for a list of regions\n\n    Args:\n        regions (Union[str, pd.DataFrame, List[GenomeRange]]): Regions to plot\n        show (bool, optional): Show the figure. Defaults to True.\n        **kwargs: Additional arguments to pass to the plot\n\n    Returns:\n        Dict[str, matplotlib.figure.Figure]: Dictionary of figures for each region\n    \"\"\"\n\n    # Format the regions into a dictionary of genome ranges\n    if isinstance(regions, pathlib.Path):\n        regions = pr.read_bed(str(regions))\n\n    if isinstance(regions, pr.PyRanges):\n        regions = {\n            (\n                row.Name if row.Name else f\"{row.Chromosome}_{row.Start}_{row.End}\"\n            ): cb.GenomeRange(\n                chrom=row.Chromosome,\n                start=row.Start,\n                end=row.End,\n            )\n            for _, row in regions.df.itertuples()\n        }\n\n    if isinstance(regions, pd.DataFrame):\n        assert (\n            \"Chromosome\" in regions.columns\n        ), \"Chromosome column not found in regions\"\n        assert \"Start\" in regions.columns, \"Start column not found in regions\"\n        assert \"End\" in regions.columns, \"End column not found in regions\"\n\n        regions = {\n            (\n                row.Name if row.Name else f\"{row.Chromosome}_{row.Start}_{row.End}\"\n            ): cb.GenomeRange(\n                chrom=row.Chromosome,\n                start=row.Start,\n                end=row.End,\n            )\n            for _, row in regions.iterrows()\n        }\n\n    plots = dict()\n    for name, gr in regions.items():\n        plots[name] = self.plot(gr, show=False, **kwargs)\n\n    return plots\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.save","title":"<code>save(gr, gr2=None, output=None, **kwargs)</code>","text":"<p>Plots the figure and saves it to a file</p> <p>Parameters:</p> Name Type Description Default <code>gr</code> <code>Union[str, GenomeRange]</code> <p>GenomeRange to plot</p> required <code>gr2</code> <code>Union[str, GenomeRange]</code> <p>Second GenomeRange to plot. Defaults to None.</p> <code>None</code> <code>output</code> <code>str</code> <p>Path to save the figure to. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the plot</p> <code>{}</code> Source code in <code>plotnado/api/figure.py</code> <pre><code>def save(\n    self,\n    gr: Union[str, cb.GenomeRange],\n    gr2: Union[str, cb.GenomeRange] = None,\n    output: str = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Plots the figure and saves it to a file\n\n    Args:\n        gr (Union[str, GenomeRange]): GenomeRange to plot\n        gr2 (Union[str, GenomeRange], optional): Second GenomeRange to plot. Defaults to None.\n        output (str, optional): Path to save the figure to. Defaults to None.\n        **kwargs: Additional arguments to pass to the plot\n    \"\"\"\n\n    fig = self.plot(gr, gr2, show=False, **kwargs)\n    if output:\n        fig.savefig(output, dpi=300, bbox_inches=\"tight\")\n    else:\n        fig.savefig(f\"{gr.chrom}_{gr.start}_{gr.end}.png\", dpi=300, bbox_inches=\"tight\")\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.Figure.to_toml","title":"<code>to_toml(output=None)</code>","text":"<p>Save the Figure to a toml file</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>Path to save the toml file to. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[None, Dict[str, Any]]</code> <p>Union[None, Dict[str, Any]]: If output is not specified, returns a dict of the toml file</p> Source code in <code>plotnado/api/figure.py</code> <pre><code>def to_toml(self, output: str = None) -&gt; Union[None, Dict[str, Any]]:\n    \"\"\"\n    Save the Figure to a toml file\n\n    Args:\n        output (str, optional): Path to save the toml file to. Defaults to None.\n\n    Returns:\n        Union[None, Dict[str, Any]]: If output is not specified, returns a dict of the toml file\n\n    \"\"\"\n\n    from collections import OrderedDict\n\n    import toml\n\n    # Ordered dict with the key being a unique identifier for the track\n    # ideally the title of the track or the track type with a number to ensure uniqueness\n    config = OrderedDict()\n    for title, track in self.tracks.items():\n        config[title] = track.to_dict()\n\n    outfile = output if output else \"config.toml\"\n\n    with open(outfile, \"w\") as f:\n        config_str = toml.dumps(config)\n        f.write(config_str)\n\n    if not output:\n        return config\n</code></pre>"},{"location":"reference/plotnado/api/figure/#plotnado.api.figure.get_track_title","title":"<code>get_track_title(track, config)</code>","text":"<p>Get the title of a track</p> <p>Parameters:</p> Name Type Description Default <code>track</code> <code>TrackWrapper</code> <p>Track to get the title of</p> required <code>config</code> <code>Dict[str, Dict]</code> <p>Configuration of the tracks</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Title of the track</p> Source code in <code>plotnado/api/figure.py</code> <pre><code>def get_track_title(track: TrackWrapper, config: Dict[str, Dict]) -&gt; str:\n    \"\"\"\n    Get the title of a track\n\n    Args:\n        track (TrackWrapper): Track to get the title of\n        config (Dict[str, Dict]): Configuration of the tracks\n\n    Returns:\n        str: Title of the track\n    \"\"\"\n\n    try:\n        title = track.properties.get(\"title\", track.track_type)\n    except AttributeError:\n        title = \"\"\n\n    if title in config:\n        n = 1\n        while f\"{title} {n}\" in config:  # Ensure the title is unique\n            n += 1\n        title = f\"{title} {n}\"\n\n    return title\n</code></pre>"},{"location":"reference/plotnado/api/genes/","title":"Genes","text":""},{"location":"reference/plotnado/api/genes/#plotnado.api.genes.PlotGenesPlotnado","title":"<code>PlotGenesPlotnado</code>","text":"<p>               Bases: <code>PlotGenes</code></p> Source code in <code>plotnado/api/genes.py</code> <pre><code>class PlotGenesPlotnado(PlotGenes):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.label_location = self.properties.get(\"label_loc\", \"mid\")\n        self.label_y_offset = self.properties.get(\"label_y_offset\", 0)\n\n    def __set_plot_params(self, gr: GenomeRange, ov_genes: pd.DataFrame):\n        properties = self.properties\n        # bed_type\n        self.properties[\"bed_type\"] = properties[\"bed_type\"] or self.infer_bed_type(\n            ov_genes\n        )\n        self.set_colormap(ov_genes)\n        # turn labels off when too many intervals are visible.\n        if properties[\"labels\"] == \"auto\":\n            if len(ov_genes) &gt; 60:\n                self.is_draw_labels = False\n            else:\n                self.is_draw_labels = True\n        self.small_relative = 0.004 * (gr.end - gr.start)\n        self.counter = 0\n\n    def __get_length_w(self, fig_width, region_start, region_end):\n        \"\"\"\n        to improve the visualization of the genes it is good to have an estimation of the label\n        length. In the following code I try to get the length of a 'W' in base pairs.\n        \"\"\"\n        if self.is_draw_labels:\n            # from http://scipy-cookbook.readthedocs.org/items/Matplotlib_LaTeX_Examples.html\n            inches_per_pt = 1.0 / 72.27\n            font_in_inches = self.properties[\"fontsize\"] * inches_per_pt\n            region_len = region_end - region_start\n            bp_per_inch = region_len / fig_width\n            font_in_bp = font_in_inches * bp_per_inch\n            self.len_w = font_in_bp\n            log.debug(\"len of w set to: {} bp\".format(self.len_w))\n        else:\n            self.len_w = 1\n\n        return self.len_w\n\n    def get_y_pos(self, free_row):\n        \"\"\"\n        The y_pos is set such that regions to be plotted do not overlap (stacked). To override this\n        the properties['collapsed'] needs to be set.\n\n        The algorithm uses a interval tree (self.region_interval) to check the overlaps\n        and a sort of coverage vector 'rows used' to identify the row in which to plot\n\n        Return\n        ------\n        ypos : int\n            y position.\n        \"\"\"\n\n        # if the domain directive is given, ypos simply oscilates between 0 and 100\n        if self.properties[\"display\"] == \"interlaced\":\n            return self.properties[\"interval_height\"] if self.counter % 2 == 0 else 1\n        elif self.properties[\"display\"] == \"collapsed\":\n            return 0\n        else:\n            return free_row * self.row_scale\n\n    def plot_genes(\n        self, ax, gr: GenomeRange, ov_genes: pd.DataFrame, dry_run=False, fig_width=None\n    ):\n        properties = self.properties\n        self.__set_plot_params(gr, ov_genes)\n\n        assert (not dry_run) or (fig_width is not None)\n        if dry_run:\n            self.__get_length_w(fig_width, gr.start, gr.end)\n        else:\n            self.__get_length_w(ax.get_figure().get_figwidth(), gr.start, gr.end)\n\n        num_rows = properties[\"num_rows\"]\n        max_num_row_local = 1\n        max_ypos = 0\n        # check for the number of other intervals that overlap\n        #    with the given interval\n        #            1         2\n        #  012345678901234567890123456\n        #  1=========       4=========\n        #       2=========\n        #         3============\n        #\n        # for 1 row_last_position = [9]\n        # for 2 row_last_position = [9, 14]\n        # for 3 row_last_position = [9, 14, 19]\n        # for 4 row_last_position = [26, 14, 19]\n\n        row_last_position = []  # each entry in this list contains the end position\n        # of genomic interval. The list index is the row\n        # in which the genomic interval was plotted.\n        # Any new genomic interval that wants to be plotted,\n        # knows the row to use by finding the list index that\n        # is larger than its start\n\n        # check for overlapping genes including\n        # label size (if plotted)\n\n        for bed in ov_genes.itertuples():\n            \"\"\"\n            BED12 gene format with exon locations at the end\n            chrX    20850   23076   CG17636-RA      0       -       20850   23017   0       3       946,765,64,     0,1031,2162,\n\n            BED9\n            bed with rgb at end\n            chr2L   0       70000   ID_5    0.26864549832   .       0       70000   51,160,44\n\n            BED6\n            bed without rgb\n            chr2L   0       70000   ID_5    0.26864549832   .\n\n            BED3\n            bed with only intervals\n            chr2L  0        70000\n            \"\"\"\n            self.counter += 1\n\n            if self.is_draw_labels and self.label_location == \"right\":\n                num_name_characters = (\n                    len(bed.name) + 2\n                )  # +2 to account for an space before and after the name\n                bed_extended_end = int(bed.end + (num_name_characters * self.len_w))\n            else:\n                bed_extended_end = bed.end + 2 * self.small_relative\n\n            # get smallest free row\n            if not row_last_position:\n                free_row = 0\n                row_last_position.append(bed_extended_end)\n            else:\n                # get list of rows that are less than bed.start, then take the min\n                idx_list = [\n                    idx\n                    for idx, value in enumerate(row_last_position)\n                    if value &lt; bed.start\n                ]\n                if len(idx_list):\n                    free_row = min(idx_list)\n                    row_last_position[free_row] = bed_extended_end\n                else:\n                    free_row = len(row_last_position)\n                    row_last_position.append(bed_extended_end)\n\n            rgb, edgecolor = self.get_rgb_and_edge_color(bed)\n            ypos = self.get_y_pos(free_row)\n\n            # do not plot if the maximum interval rows to plot is reached\n            if num_rows and free_row &gt;= float(num_rows):\n                continue\n\n            if free_row &gt; max_num_row_local:\n                max_num_row_local = free_row\n            if ypos &gt; max_ypos:\n                max_ypos = ypos\n\n            if not dry_run:\n                if properties[\"bed_type\"] == \"bed12\":\n                    if properties[\"gene_style\"] == \"flybase\":\n                        self.draw_gene_with_introns_flybase_style(\n                            ax, bed, ypos, rgb, edgecolor\n                        )\n                    else:\n                        self._draw_gene_with_introns(\n                            ax,\n                            bed,\n                            ypos,\n                            rgb,\n                            edgecolor,\n                            arrow_color=properties.get(\"arrow_color\", \"black\"),\n                        )\n                else:\n                    self.draw_gene_simple(ax, bed, ypos, rgb, edgecolor)\n\n                self.draw_label(bed, gr, ax, ypos)\n\n        if self.counter == 0:\n            log.debug(\n                f\"*Warning* No intervals were found for file {properties['file']} \"\n                f\"in Track '{properties['name']}' for the interval plotted ({gr}).\\n\"\n            )\n\n        ymax = 0\n        if num_rows:\n            ymin = float(num_rows) * self.row_scale\n            self.current_row_num = num_rows\n        else:\n            ymin = max_ypos + properties[\"interval_height\"]\n            self.current_row_num = len(row_last_position)\n\n        log.debug(\"ylim {},{}\".format(ymin, ymax))\n        # the axis is inverted (thus, ymax &lt; ymin)\n        if not dry_run:\n            ax.set_ylim(ymin, ymax)\n\n            if properties[\"display\"] == \"collapsed\":\n                ax.set_ylim(-5, 105)\n\n            ax.set_xlim(gr.start, gr.end)\n\n    def draw_label(self, bed, gr, ax, ypos):\n        if self.is_draw_labels:\n            # if the label is to be plotted on the right side\n            if self.label_location == \"right\":\n                # Check if the label is within the genomic range if not writ the label at the middle of the gene\n                if bed.start &gt; gr.start and bed.end &lt; gr.end:\n                    self._draw_label_right(bed, gr, ax, ypos)\n                elif bed.start &lt; gr.end and bed.end &gt; gr.end:\n                    self._draw_label_mid(bed, gr, ax, ypos)\n\n            elif self.label_location == \"mid\":\n                self._draw_label_mid(bed, gr, ax, ypos)\n\n    def _draw_label_right(self, bed, gr, ax, ypos):\n        ax.text(\n            bed.end + self.small_relative,\n            ypos + (float(self.properties[\"interval_height\"]) / 2),\n            bed.name,\n            horizontalalignment=\"left\",\n            verticalalignment=\"center\",\n            fontproperties=self.fp,\n        )\n\n    def _draw_label_mid(self, bed, gr, ax, ypos):\n        # Intersect the gene with the genomic range\n        start = max(bed.start, gr.start)\n        end = min(bed.end, gr.end)\n        # Calculate the middle of the gene\n        mid = (start + end) / 2\n        ax.text(\n            mid,\n            ypos\n            + (float(self.properties[\"interval_height\"]) / 2)\n            + self.label_y_offset,\n            bed.name,\n            horizontalalignment=\"center\",\n            verticalalignment=\"center\",\n            fontproperties=self.fp,\n        )\n\n    def _draw_gene_with_introns(\n        self, ax, bed, ypos, rgb, edgecolor, arrow_color=\"blue\"\n    ):\n        \"\"\"\n        draws a gene like in flybase gbrowse.\n        \"\"\"\n        from matplotlib.patches import Polygon\n\n        properties = self.properties\n        height = float(properties[\"interval_height\"])\n\n        if (\n            bed.block_count == 0\n            and bed.thick_start == bed.start\n            and bed.thick_end == bed.end\n        ):\n            self.draw_gene_simple(ax, bed, ypos, rgb, edgecolor)\n            return\n        half_height = height / 2\n        quarter_height = height / 4\n        three_quarter_height = quarter_height * 3\n\n        # draw 'backbone', a line from the start until the end of the gene\n        ax.plot(\n            [bed.start, bed.end],\n            [ypos + half_height, ypos + half_height],\n            \"black\",\n            linewidth=0.5,\n            zorder=-1,\n        )\n\n        for idx in range(bed.block_count):\n            x0 = bed.start + bed.block_starts[idx]\n            x1 = x0 + bed.block_sizes[idx]\n            if x1 &lt; bed.thick_start or x0 &gt; bed.thick_end:\n                y0 = ypos + quarter_height\n                y1 = ypos + three_quarter_height\n            else:\n                y0 = ypos\n                y1 = ypos + height\n\n            if x0 &lt; bed.thick_start &lt; x1:\n                vertices = [\n                    (x0, ypos + quarter_height),\n                    (x0, ypos + three_quarter_height),\n                    (bed.thick_start, ypos + three_quarter_height),\n                    (bed.thick_start, ypos + height),\n                    (bed.thick_start, ypos + height),\n                    (x1, ypos + height),\n                    (x1, ypos),\n                    (bed.thick_start, ypos),\n                    (bed.thick_start, ypos + quarter_height),\n                ]\n\n            elif x0 &lt; bed.thick_end &lt; x1:\n                vertices = [\n                    (x0, ypos),\n                    (x0, ypos + height),\n                    (bed.thick_end, ypos + height),\n                    (bed.thick_end, ypos + three_quarter_height),\n                    (x1, ypos + three_quarter_height),\n                    (x1, ypos + quarter_height),\n                    (bed.thick_end, ypos + quarter_height),\n                    (bed.thick_end, ypos),\n                ]\n            else:\n                vertices = [(x0, y0), (x0, y1), (x1, y1), (x1, y0)]\n\n            ax.add_patch(\n                Polygon(\n                    vertices,\n                    closed=True,\n                    fill=True,\n                    linewidth=0.1,\n                    edgecolor=\"none\",\n                    facecolor=rgb,\n                )\n            )\n\n            if idx &lt; bed.block_count - 1:\n                # plot small arrows using the character '&lt;' or '&gt;' over the back bone\n                intron_length = bed.block_starts[idx + 1] - (\n                    bed.block_starts[idx] + bed.block_sizes[idx]\n                )\n                marker = 5 if bed.strand == \"+\" else 4\n                if intron_length &gt; 3 * self.small_relative:\n                    pos = np.arange(\n                        x1 + 1 * self.small_relative,\n                        x1 + intron_length + self.small_relative,\n                        int(2 * self.small_relative),\n                    )\n                    ax.plot(\n                        pos,\n                        np.zeros(len(pos)) + ypos + half_height,\n                        \".\",\n                        marker=marker,\n                        fillstyle=\"none\",\n                        color=arrow_color,\n                        markersize=3,\n                    )\n\n                elif intron_length &gt; self.small_relative:\n                    intron_center = x1 + int(intron_length) / 2\n                    ax.plot(\n                        [intron_center],\n                        [ypos + half_height],\n                        \".\",\n                        marker=5,\n                        fillstyle=\"none\",\n                        color=arrow_color,\n                        markersize=3,\n                    )\n</code></pre>"},{"location":"reference/plotnado/api/genes/#plotnado.api.genes.PlotGenesPlotnado.__get_length_w","title":"<code>__get_length_w(fig_width, region_start, region_end)</code>","text":"<p>to improve the visualization of the genes it is good to have an estimation of the label length. In the following code I try to get the length of a 'W' in base pairs.</p> Source code in <code>plotnado/api/genes.py</code> <pre><code>def __get_length_w(self, fig_width, region_start, region_end):\n    \"\"\"\n    to improve the visualization of the genes it is good to have an estimation of the label\n    length. In the following code I try to get the length of a 'W' in base pairs.\n    \"\"\"\n    if self.is_draw_labels:\n        # from http://scipy-cookbook.readthedocs.org/items/Matplotlib_LaTeX_Examples.html\n        inches_per_pt = 1.0 / 72.27\n        font_in_inches = self.properties[\"fontsize\"] * inches_per_pt\n        region_len = region_end - region_start\n        bp_per_inch = region_len / fig_width\n        font_in_bp = font_in_inches * bp_per_inch\n        self.len_w = font_in_bp\n        log.debug(\"len of w set to: {} bp\".format(self.len_w))\n    else:\n        self.len_w = 1\n\n    return self.len_w\n</code></pre>"},{"location":"reference/plotnado/api/genes/#plotnado.api.genes.PlotGenesPlotnado.get_y_pos","title":"<code>get_y_pos(free_row)</code>","text":"<p>The y_pos is set such that regions to be plotted do not overlap (stacked). To override this the properties['collapsed'] needs to be set.</p> <p>The algorithm uses a interval tree (self.region_interval) to check the overlaps and a sort of coverage vector 'rows used' to identify the row in which to plot</p>"},{"location":"reference/plotnado/api/genes/#plotnado.api.genes.PlotGenesPlotnado.get_y_pos--return","title":"Return","text":"<p>ypos : int     y position.</p> Source code in <code>plotnado/api/genes.py</code> <pre><code>def get_y_pos(self, free_row):\n    \"\"\"\n    The y_pos is set such that regions to be plotted do not overlap (stacked). To override this\n    the properties['collapsed'] needs to be set.\n\n    The algorithm uses a interval tree (self.region_interval) to check the overlaps\n    and a sort of coverage vector 'rows used' to identify the row in which to plot\n\n    Return\n    ------\n    ypos : int\n        y position.\n    \"\"\"\n\n    # if the domain directive is given, ypos simply oscilates between 0 and 100\n    if self.properties[\"display\"] == \"interlaced\":\n        return self.properties[\"interval_height\"] if self.counter % 2 == 0 else 1\n    elif self.properties[\"display\"] == \"collapsed\":\n        return 0\n    else:\n        return free_row * self.row_scale\n</code></pre>"},{"location":"reference/plotnado/api/patches/","title":"Patches","text":""},{"location":"reference/plotnado/api/track_wrapper/","title":"Track wrapper","text":""},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper","title":"<code>TrackWrapper</code>","text":"<p>Provides a wrapper around tracks to provide a consistent interface</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Path to file to plot</p> <code>None</code> <code>track_class</code> <p>Class to use for the track or alias</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/track_wrapper.py</code> <pre><code>class TrackWrapper:\n    \"\"\"\n    Provides a wrapper around tracks to provide a consistent interface\n\n    Args:\n        file (os.PathLike): Path to file to plot\n        track_class: Class to use for the track or alias\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(\n        self,\n        track_type: Union[str, TrackType, Any],\n        file: Optional[Union[str, List[str]]] = None,\n        **kwargs,\n    ):\n        \"\"\"\n        Initialize a TrackWrapper\n\n        Args:\n            track_type (Union[str, TrackType]): Type of track to plot\n            file (Optional[Union[str, List[str]]], optional): Path to file to plot. Defaults to None.\n            **kwargs: Additional arguments to pass to the track\n        \"\"\"\n\n        # Check if the track type is a string, enum or class\n        # and convert it to a string\n\n        # First check if the track type is an enum\n        if isinstance(track_type, TrackType):\n            self.track_type = track_type.name\n\n        # If it is a string, check if it is a valid track type\n        elif isinstance(track_type, str):\n            # Check if the track type is a valid track type\n            if track_type in [t.name for t in TrackType]:\n                self.track_type = TrackType[track_type].name\n            elif hasattr(cb, track_type):\n                # Is the track type a class in the coolbox api\n                self.track_type = track_type\n\n        elif hasattr(cb, type(track_type).__name__):\n            # Check if the track type is a class in the coolbox api\n            self.track_type = type(track_type).__name__\n\n        else:\n            # If the track type is not a valid track type\n            # raise an error\n            raise ValueError(\n                f\"Unknown track type {track_type}, select from: {', '.join([t.name for t in TrackType])} or provide a custom track class\"\n            )\n\n        self.file = file\n        self.properties = dict()\n        self.properties.update(kwargs)\n\n    @property\n    def track_class(self):\n        \"\"\"\n        Get the track class\n        \"\"\"\n\n        try:\n            track_class = TrackType[self.track_type].value\n        except KeyError:\n            if getattr(cb, self.track_type):\n                track_class = getattr(cb, self.track_type)\n            elif self.track_type in [*CUSTOM_TRACKS, *BIGWIG_TRACKS, *MATRIX_TRACKS]:\n                track_class = self.track_type\n            else:\n                raise ValueError(\n                    f\"Unknown track type {self.track_type}, select from: {', '.join([t.name for t in TrackType])} or provide a custom track class\"\n                )\n\n        return track_class\n\n    @property\n    def track(self) -&gt; cb.Track:\n        \"\"\"\n        Get the track object with the specified properties and adding track type specific properties\n        \"\"\"\n\n        if self.file is None and self.track_class in [t.value for t in FilelessTracks]:\n            track = self.track_class(**self.properties)\n\n        elif self.track_class in AGGREGATED_TRACKS_FILE:\n            assert all(\n                [pathlib.Path(p).exists() for p in self.file]\n            ), f\"Not files provided to track {self.track_class} exist\"\n            track = self.track_class(self.file, **self.properties)\n\n        elif self.track_class in AGGREGATED_TRACKS_MEMMORY:\n            tracks = []\n            for t in self.file:\n                if isinstance(t, TrackWrapper):\n                    tracks.append(t.track)\n                else:\n                    tracks.append(t)\n\n            track = self.track_class(tracks, **self.properties)\n\n        elif self.track_class in ALLOWED_NON_FILE_TRACKS:\n            track = self.track_class(self.file, **self.properties)\n\n        elif pathlib.Path(self.file).exists():\n            track = self.track_class(self.file, **self.properties)\n\n        elif self.properties.get(\"ignore_file_validation\"):\n            track = self.track_class(self.file, **self.properties)\n\n        elif URL_REGEX.match(self.file):\n            track = self.track_class(self.file, **self.properties)\n\n        else:\n            raise FileNotFoundError(f\"File {self.file} does not exist\")\n\n        return self._patch_track(track)\n\n    def _patch_track(self, track: cb.Track) -&gt; cb.Track:\n        \"\"\"\n        Patch the track with new functionality\n        \"\"\"\n        if self.properties.get(\"data_range_location\"):\n            track.plot_text_range = functools.partial(plot_text_range, track)\n\n        if self.properties.get(\"label_on_track\"):\n            track.plot_label = functools.partial(plot_label, track)\n\n        return track\n\n    @property\n    def path(self) -&gt; str:\n        \"\"\"\n        Get the path to the 'file' attribute these can be either a ssingle file or a list of files\n        \"\"\"\n        _files = []\n        if isinstance(self.file, (list, tuple, np.ndarray)):\n            for f in self.file:\n                if isinstance(f, (TrackWrapper, cb.Track)):\n                    if hasattr(f, \"file\"):\n                        _file = f.file\n                    elif f.properties.get(\"file\"):\n                        _file = f.properties[\"file\"]\n                elif isinstance(f, (str, pathlib.Path)):\n                    _file = f\n                _files.append(_file)\n        elif self.file is None:\n            return None\n        else:\n            _files.append(self.file)\n\n        files = []\n        for f in _files:\n            if URL_REGEX.match(f):\n                files.append(f)\n            elif pathlib.Path(f).exists():\n                files.append(str(pathlib.Path(f).resolve()))\n            elif self.properties.get(\n                \"ignore_file_validation\"\n            ) or self.track.properties.get(\"ignore_file_validation\"):\n                files.append(f)\n            else:\n                raise FileNotFoundError(f\"File {f} does not exist\")\n\n        if len(files) == 1:\n            return files[0]\n        else:\n            return tuple(files)\n\n    @property\n    def autoscale_group(self) -&gt; str:\n        \"\"\"\n        Get the autoscale group\n        \"\"\"\n        return self.properties.get(\"autoscale_group\", None)\n\n    def to_dict(self) -&gt; Dict:\n        \"\"\"\n        Convert the TrackWrapper to a dictionarys\n        \"\"\"\n\n        # Check to see if the track has subtracks\n        # need to handle this differently\n        if hasattr(self.track, \"subtracks\"):\n            subtracks = OrderedDict()\n            for track in self.track.subtracks:\n                subtracks[track.properties[\"name\"]] = TrackWrapper(\n                    track_type=type(track).__name__, **track.properties\n                ).to_dict()\n\n            return {\n                \"track_type\": self.track_type,\n                \"file\": self.path,\n                \"subtracks\": subtracks,\n                **self.properties,\n            }\n        else:\n            return {\n                \"track_type\": self.track_type,\n                \"file\": self.path,\n                **self.properties,\n            }\n\n    @classmethod\n    def from_dict(cls, data: Dict):\n        \"\"\"\n        Load the TrackWrapper from a dictionary\n        \"\"\"\n\n        if \"subtracks\" in data:\n            subtracks = []\n            for subtrack_name, subtrack_data in data[\"subtracks\"].items():\n                subtracks.append(TrackWrapper.from_dict(subtrack_data).track)\n            data[\"file\"] = subtracks\n\n        return cls(**data)\n\n    def __repr__(self) -&gt; str:\n        title = self.properties.get(\"title\", \"No title\")\n        track_class = self.track_class\n        return f\"TrackWrapper({title}, {track_class})\"\n</code></pre>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.autoscale_group","title":"<code>autoscale_group</code>  <code>property</code>","text":"<p>Get the autoscale group</p>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.path","title":"<code>path</code>  <code>property</code>","text":"<p>Get the path to the 'file' attribute these can be either a ssingle file or a list of files</p>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.track","title":"<code>track</code>  <code>property</code>","text":"<p>Get the track object with the specified properties and adding track type specific properties</p>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.track_class","title":"<code>track_class</code>  <code>property</code>","text":"<p>Get the track class</p>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.__init__","title":"<code>__init__(track_type, file=None, **kwargs)</code>","text":"<p>Initialize a TrackWrapper</p> <p>Parameters:</p> Name Type Description Default <code>track_type</code> <code>Union[str, TrackType]</code> <p>Type of track to plot</p> required <code>file</code> <code>Optional[Union[str, List[str]]]</code> <p>Path to file to plot. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/track_wrapper.py</code> <pre><code>def __init__(\n    self,\n    track_type: Union[str, TrackType, Any],\n    file: Optional[Union[str, List[str]]] = None,\n    **kwargs,\n):\n    \"\"\"\n    Initialize a TrackWrapper\n\n    Args:\n        track_type (Union[str, TrackType]): Type of track to plot\n        file (Optional[Union[str, List[str]]], optional): Path to file to plot. Defaults to None.\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    # Check if the track type is a string, enum or class\n    # and convert it to a string\n\n    # First check if the track type is an enum\n    if isinstance(track_type, TrackType):\n        self.track_type = track_type.name\n\n    # If it is a string, check if it is a valid track type\n    elif isinstance(track_type, str):\n        # Check if the track type is a valid track type\n        if track_type in [t.name for t in TrackType]:\n            self.track_type = TrackType[track_type].name\n        elif hasattr(cb, track_type):\n            # Is the track type a class in the coolbox api\n            self.track_type = track_type\n\n    elif hasattr(cb, type(track_type).__name__):\n        # Check if the track type is a class in the coolbox api\n        self.track_type = type(track_type).__name__\n\n    else:\n        # If the track type is not a valid track type\n        # raise an error\n        raise ValueError(\n            f\"Unknown track type {track_type}, select from: {', '.join([t.name for t in TrackType])} or provide a custom track class\"\n        )\n\n    self.file = file\n    self.properties = dict()\n    self.properties.update(kwargs)\n</code></pre>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.from_dict","title":"<code>from_dict(data)</code>  <code>classmethod</code>","text":"<p>Load the TrackWrapper from a dictionary</p> Source code in <code>plotnado/api/track_wrapper.py</code> <pre><code>@classmethod\ndef from_dict(cls, data: Dict):\n    \"\"\"\n    Load the TrackWrapper from a dictionary\n    \"\"\"\n\n    if \"subtracks\" in data:\n        subtracks = []\n        for subtrack_name, subtrack_data in data[\"subtracks\"].items():\n            subtracks.append(TrackWrapper.from_dict(subtrack_data).track)\n        data[\"file\"] = subtracks\n\n    return cls(**data)\n</code></pre>"},{"location":"reference/plotnado/api/track_wrapper/#plotnado.api.track_wrapper.TrackWrapper.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the TrackWrapper to a dictionarys</p> Source code in <code>plotnado/api/track_wrapper.py</code> <pre><code>def to_dict(self) -&gt; Dict:\n    \"\"\"\n    Convert the TrackWrapper to a dictionarys\n    \"\"\"\n\n    # Check to see if the track has subtracks\n    # need to handle this differently\n    if hasattr(self.track, \"subtracks\"):\n        subtracks = OrderedDict()\n        for track in self.track.subtracks:\n            subtracks[track.properties[\"name\"]] = TrackWrapper(\n                track_type=type(track).__name__, **track.properties\n            ).to_dict()\n\n        return {\n            \"track_type\": self.track_type,\n            \"file\": self.path,\n            \"subtracks\": subtracks,\n            **self.properties,\n        }\n    else:\n        return {\n            \"track_type\": self.track_type,\n            \"file\": self.path,\n            **self.properties,\n        }\n</code></pre>"},{"location":"reference/plotnado/api/tracks/","title":"Tracks","text":""},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.Autoscaler","title":"<code>Autoscaler</code>","text":"<p>Autoscale the data from multiple tracks to a single scale.</p> <p>Parameters:</p> Name Type Description Default <code>tracks</code> <code>List[Track]</code> <p>List of tracks to autoscale</p> required <code>gr</code> <code>GenomeRange</code> <p>Genome range to fetch the data</p> required <code>gr2</code> <code>GenomeRange</code> <p>Second genome range for 2D data. Defaults to None.</p> <code>None</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class Autoscaler:\n    \"\"\"\n    Autoscale the data from multiple tracks to a single scale.\n\n    Args:\n        tracks (List[cb.Track]): List of tracks to autoscale\n        gr (cb.GenomeRange): Genome range to fetch the data\n        gr2 (cb.GenomeRange, optional): Second genome range for 2D data. Defaults to None.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        tracks: List[cb.Track],\n        gr: cb.GenomeRange,\n        gr2: cb.GenomeRange = None,\n    ):\n        self.tracks = tracks\n        self.gr = gr\n        self.gr2 = gr2\n\n        from .track_wrapper import MATRIX_TRACKS, BIGWIG_TRACKS, TrackWrapper\n\n        assert len(tracks) &gt; 0, \"No tracks to autoscale\"\n        assert all(\n            isinstance(t, (cb.Track, TrackWrapper)) for t in tracks\n        ), \"All tracks must be of type cb.Track\"\n        assert all(\n            type(t) in MATRIX_TRACKS + BIGWIG_TRACKS for t in tracks\n        ), \"All tracks must be of tracks that produce numerical data (MatrixCapcruncher, BigWig, etc)\"\n\n    @property\n    def data(self):\n        \"\"\"\n        Get the data from all tracks for the specified region\n        \"\"\"\n        _data = [t.fetch_data(gr=self.gr, gr2=self.gr2) for t in self.tracks]\n\n        if isinstance(\n            _data[0], pd.DataFrame\n        ):  # If the data is a DataFrame, we need to extract the values from the last column\n            _data = [d.values[:, -1] for d in _data]\n        elif isinstance(_data[0], np.ndarray):\n            pass\n\n        return np.concatenate(_data, axis=0)\n\n    @property\n    def max_value(self):\n        return np.nanmax(self.data, axis=0)\n\n    @property\n    def min_value(self):\n        return min(0, np.nanmin(self.data, axis=0))\n\n    @property\n    def mean_value(self):\n        return np.nanmean(self.data, axis=0)\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.Autoscaler.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the data from all tracks for the specified region</p>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BedMemory","title":"<code>BedMemory</code>","text":"<p>               Bases: <code>Track</code></p> <p>A bed track that is stored in memory as  pyranges object</p> <p>Parameters:</p> Name Type Description Default <code>pyranges</code> <code>PyRanges</code> <p>A pyranges object</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BedMemory(Track):\n    \"\"\"\n    A bed track that is stored in memory as  pyranges object\n\n    Args:\n        pyranges (pr.PyRanges): A pyranges object\n        **kwargs: Additional arguments to pass to the track\n\n    \"\"\"\n\n    def __init__(self, pyranges: pr.PyRanges, **kwargs):\n        self.file = None\n        self.pyranges = pyranges\n        self.properties = dict()\n        self.properties[\"name\"] = \"MemmoryBed\"\n        self.properties.update(kwargs)\n\n    def fetch_data(self, gr: GenomeRange):\n        interval = interval_to_pyranges(gr)\n\n        return self.pyranges.intersect(interval)\n\n    def plot(self, ax, gr, **kwargs):\n        data = self.fetch_data(gr)\n        y_midpoint = 0.5\n\n        for interval in data.as_df().itertuples():\n            if hasattr(interval, \"color\"):\n                color = interval.color\n            else:\n                color = self.properties.get(\"color\", \"black\")\n\n            pg = Polygon(\n                [\n                    (interval.Start, y_midpoint - 0.1),\n                    (interval.Start, y_midpoint + 0.1),\n                    (interval.End, y_midpoint + 0.1),\n                    (interval.End, y_midpoint - 0.1),\n                ],\n                color=color,\n            )\n\n            if hasattr(interval, \"Name\") and not self.properties.get(\"no_annotation\"):\n                interval_midpoint = interval.Start + (\n                    (interval.End - interval.Start) / 2\n                )\n                ax.text(\n                    interval_midpoint,\n                    y_midpoint - 0.1,\n                    interval.Name,\n                    ha=\"center\",\n                    va=\"center\",\n                )\n\n            ax.add_patch(pg)\n\n        ax.set_xlim(gr.start, gr.end)\n        ax.set_ylim(0, 1)\n\n    def plot_label(self):\n        if hasattr(self, \"label_ax\") and self.label_ax is not None:\n            self.label_ax.text(\n                0.15,\n                0.5,\n                self.properties[\"title\"],\n                horizontalalignment=\"left\",\n                size=\"large\",\n                verticalalignment=\"center\",\n            )\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BedSimple","title":"<code>BedSimple</code>","text":"<p>               Bases: <code>BED</code></p> <p>Simplified version of the Bed class that only plots the intervals as rectangles.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Path to the bed file</p> required Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BedSimple(cb.BED):\n    \"\"\"\n    Simplified version of the Bed class that only plots the intervals as rectangles.\n\n    Args:\n        file (os.PathLike): Path to the bed file\n    \"\"\"\n\n    def __init__(self, file: str, **kwargs):\n        self.file = file\n        self.properties = dict()\n        self.properties[\"name\"] = f\"SimpleBed_{self.properties.get('title')}\"\n        self.properties.update(kwargs)\n\n    def fetch_data(self, gr):\n        bt = BedTool(self.file)\n\n        try:\n            bt_tabix = bt.tabix(force=True)\n            intervals = bt_tabix.tabix_intervals(\n                f\"{gr.chrom}:{gr.start}-{gr.end}\"\n            )\n\n        except OSError: # Handle the case where the bed file is not tabix indexed or the user does not have permission to write to the directory\n            import tempfile\n            with tempfile.NamedTemporaryFile() as tmp:\n                bt.saveas(tmp.name)\n                bt_tabix = BedTool(tmp.name).tabix(force=True)\n                intervals = bt_tabix.tabix_intervals(\n                    f\"{gr.chrom}:{gr.start}-{gr.end}\"\n                )\n\n        return intervals\n\n    def plot(self, ax, gr, **kwargs):\n        data = self.fetch_data(gr)\n        y_midpoint = 0.5\n\n        for interval in data.intervals:\n            pg = Polygon(\n                [\n                    (interval.start, y_midpoint - 0.1),\n                    (interval.start, y_midpoint + 0.1),\n                    (interval.end, y_midpoint + 0.1),\n                    (interval.end, y_midpoint - 0.1),\n                ],\n                color=self.properties.get(\"color\", \"black\"),\n            )\n\n            if hasattr(interval, \"name\") and not self.properties.get(\"no_annotation\"):\n                interval_midpoint = interval.start + (\n                    (interval.end - interval.start) / 2\n                )\n                ax.text(\n                    interval_midpoint,\n                    y_midpoint - 0.1,\n                    interval.name,\n                    ha=\"center\",\n                    va=\"center\",\n                )\n\n            ax.add_patch(pg)\n\n        ax.set_xlim(gr.start, gr.end)\n        ax.set_ylim(0, 1)\n\n        if self.properties.get('title'):\n            self.plot_label()\n\n    def adjust_plot(self, ax, gr: GenomeRange):\n        ax.set_xlim(gr.start, gr.end)\n        ymin, ymax = ax.get_ylim()\n        return ymin, ymax\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BigwigFragment","title":"<code>BigwigFragment</code>","text":"<p>               Bases: <code>BigWig</code></p> <p>Subclass of BigWig that plots fragments instead of lines. Provides a more accurate representation of the data.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Path to the bigwig file</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BigwigFragment(cb.BigWig):\n    \"\"\"\n    Subclass of BigWig that plots fragments instead of lines. Provides a more accurate representation of the data.\n\n    Args:\n        file (os.PathLike): Path to the bigwig file\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(self, file, **kwargs):\n        self.file = file\n        self.coverages = []\n\n        super(BigwigFragment, self).__init__(file, **kwargs)\n\n    def fetch_data(self, gr, **kwargs):\n        if not self.properties[\"style\"] == \"fragment\":\n            data = super(BigwigFragment, self).fetch_data(gr, **kwargs)\n        else:\n            data = self.bw.fetch_intervals(gr.chrom, gr.start, gr.end)\n\n        return data\n\n    def plot_fragments(self, ax, gr, **kwargs):\n        data = self.fetch_data(gr, **kwargs)\n        _alpha = self.properties.get(\"alpha\", 1.0)\n        _threshold = self.properties.get(\"threshold\", 0)\n        _offset = gr.start\n        bp_proportion = 1 / (data[\"end\"].max() - data[\"start\"].min())\n\n        for row in data.itertuples():\n            pg = Polygon(\n                [\n                    (row.start, 0),\n                    (row.start, row.value),\n                    (row.end, row.value),\n                    (row.end, 0),\n                ],\n                color=self.properties[\"color\"],\n            )\n            ax.add_patch(pg)\n\n        ax.set_ylim(0, data[\"value\"].max())\n        ymin, ymax = self.adjust_plot(ax, gr)\n\n        if self.properties.get(\"show_data_range\") == \"yes\" and not self.properties.get(\n            \"is_subtrack\"\n        ):\n            self.plot_data_range(\n                ax, ymin, ymax, self.properties[\"data_range_style\"], gr\n            )\n\n        if self.properties.get(\"label_on_track\") and not self.properties.get(\n            \"is_subtrack\"\n        ):\n            self.plot_label()\n\n    def plot(self, ax, gr, **kwargs):\n        if not self.properties[\"style\"] == \"fragment\":\n            super(BigwigFragment, self).plot(ax, gr, **kwargs)\n        else:\n            self.plot_fragments(ax, gr, **kwargs)\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BigwigFragmentCollection","title":"<code>BigwigFragmentCollection</code>","text":"<p>               Bases: <code>Track</code></p> <p>Aggregates multiple bigwig files into a single track. Plots mean and standard error of the mean.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>list</code> <p>List of paths to the bigwig files</p> required <code>exclusions</code> <code>str</code> <p>Path to a bed file containing regions to exclude. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BigwigFragmentCollection(Track):\n    \"\"\"\n    Aggregates multiple bigwig files into a single track. Plots mean and standard error of the mean.\n\n\n    Args:\n        file (list): List of paths to the bigwig files\n        exclusions (str, optional): Path to a bed file containing regions to exclude. Defaults to None.\n        **kwargs: Additional arguments to pass to the track\n\n    \"\"\"\n\n    DEFAULT_PROPERTIES = {\n        \"style\": \"line\",\n        \"fmt\": \"-\",\n        \"line_width\": 2.0,\n        \"size\": 10,\n        \"color\": \"#a6cee3\",\n        \"threshold_color\": \"#ff9c9c\",\n        \"threshold\": \"inf\",\n        \"cmap\": \"bwr\",\n        \"orientation\": None,\n        \"data_range_style\": \"y-axis\",\n        \"min_value\": \"auto\",\n        \"max_value\": \"auto\",\n    }\n\n    def __init__(self, file: list, exclusions: str = None, **kwargs):\n        self.file_names = file\n        self.exclusions = exclusions\n        self.bws = (\n            [cb.BigWig(str(fn)) for fn in file]\n            if not isinstance(file[0], cb.BigWig)\n            else file\n        )\n        self.properties = {\"files\": self.file_names}\n        self.properties.update(BigwigFragmentCollection.DEFAULT_PROPERTIES.copy())\n        self.properties.update(kwargs)\n        self.properties[\"name\"] = f\"BigWigCollection.{self.properties.get('title')}\"\n        super(BigwigFragmentCollection, self).__init__(**self.properties)\n\n        self.coverages = []\n\n        # load features from global feature stack\n        features_stack = get_feature_stack()\n        for features in features_stack:\n            self.properties.update(features.properties)\n\n        # load coverages from global coverages stack\n        coverage_stack = get_coverage_stack()\n        for coverage in coverage_stack:\n            self.coverages.append(coverage)\n\n    @property\n    def subtracks(self):\n        return self.bws\n\n    def fetch_data(self, gr, **kwargs):\n        datasets = [\n            bw.bw.fetch_intervals(gr.chrom, gr.start, gr.end)\n            .set_index([\"chrom\", \"start\", \"end\"])\n            .rename(columns={\"value\": os.path.basename(bw.properties[\"file\"])})\n            for bw in self.bws\n        ]\n        df = datasets[0].join(datasets[1:])\n        df_summary = df.assign(mean=df.mean(axis=1), sem=df.sem(axis=1)).reset_index()\n\n        intervals_to_bp = []\n        for interval in df_summary.itertuples():\n            interval_len = interval.end - interval.start\n\n            interval_positions = np.arange(interval_len) + interval.start\n            scores_mean = np.repeat(interval.mean, interval_len)\n            scores_sem = np.repeat(interval.sem, interval_len)\n\n            intervals_to_bp.append(\n                np.vstack([interval_positions, scores_mean, scores_sem]).T\n            )\n\n        df_intervals = pd.DataFrame(\n            np.concatenate(intervals_to_bp), columns=[\"bp\", \"mean\", \"sem\"]\n        )\n\n        if self.exclusions:\n            df_intervals = pd.concat(\n                [df_intervals, self.fetch_exluded_regions(gr)]\n            ).sort_values(\"bp\")\n\n        if self.properties.get(\"smooth_window\") or self.properties.get(\"smooth\"):\n            from scipy.signal import savgol_filter\n\n            df_intervals[\"mean_smoothed\"] = savgol_filter(\n                df_intervals[\"mean\"],\n                window_length=self.properties.get(\"smooth_window\", 1001),\n                polyorder=self.properties.get(\"polyorder\", 1),\n            )\n\n        return df_intervals\n\n    def fetch_exluded_regions(self, gr):\n        excluded_tabix = BedTool(self.exclusions).tabix(force=True)\n        df_excluded = excluded_tabix.tabix_intervals(\n            f\"{gr.chrom}:{gr.start}-{gr.end}\"\n        ).to_dataframe()\n\n        intervals_to_bp = []\n        for interval in df_excluded.itertuples():\n            interval_len = interval.end - interval.start\n\n            interval_positions = np.arange(interval_len) + interval.start\n            scores_nan = np.repeat(np.nan, interval_len)\n            intervals_to_bp.append(interval_positions)\n\n        df_intervals = pd.Series(np.concatenate(intervals_to_bp)).to_frame(\"bp\")\n        df_intervals[\"mean\"] = np.nan\n        df_intervals[\"sem\"] = np.nan\n\n        return df_intervals\n\n    def plot(self, ax, gr, **kwargs):\n        data = self.fetch_data(gr, **kwargs)\n\n        line_width = self.properties.get(\"line_width\", 1)\n        color = self.properties.get(\"color\", \"blue\")\n        alpha = self.properties.get(\"alpha\", 0.2)\n        downsample = self.properties.get(\n            \"downsample\", 10\n        )  # downsample the data to make it faster to plot\n\n        if downsample:\n            rows = np.arange(0, data.shape[0], downsample)\n            data = data.iloc[rows]\n\n        if self.properties.get(\"smooth_window\"):\n            scores = data[\"mean_smoothed\"]\n        else:\n            scores = data[\"mean\"]\n\n        ax.fill_between(\n            data[\"bp\"],\n            scores - data[\"sem\"],\n            scores + data[\"sem\"],\n            alpha=alpha,\n            color=color,\n            zorder=0,\n        )\n\n        ax.plot(\n            data[\"bp\"],\n            scores,\n            color=color,\n            zorder=1,\n            linewidth=line_width,\n        )\n\n        min_val = self.properties.get(\"min_value\")\n        max_val = self.properties.get(\"max_value\")\n\n        ymin = round(scores.min()) if min_val == \"auto\" else min_val\n        ymin = min(0, ymin)\n\n        ymax = round(scores.max() + data[\"sem\"].max()) if max_val == \"auto\" else max_val\n\n        ax.set_xlim(gr.start, gr.end)\n        ax.set_ylim(ymin, ymax)\n\n        if not self.properties.get(\"is_subtrack\"):\n            self.plot_data_range(\n                ax, ymin, ymax, self.properties[\"data_range_style\"], gr\n            )\n\n        if self.properties.get(\"label_on_track\") and not self.properties.get(\n            \"is_subtrack\"\n        ):\n            self.plot_label()\n\n    def plot_data_range(self, ax, ymin, ymax, data_range_style, gr: cb.GenomeRange):\n        if data_range_style == \"text\":\n            self._plot_text_range(ax, ymin, ymax, gr)\n        else:  # 'y-axis' style\n            try:\n                y_ax = self.y_ax\n                self.plot_yaxis_range(ax, y_ax)\n            except AttributeError:\n                self.plot_data_range(ax, ymin, ymax, \"text\", gr)\n\n    def _plot_text_range(self, ax, ymin, ymax, gr: cb.GenomeRange):\n        plot_text_range(self, ax, ymin, ymax, gr)\n\n    def plot_yaxis_range(self, plot_axis, y_ax):\n        # \"\"\"\n        # Plot the scale of the y axis with respect to the plot_axis\n        # plot something that looks like this:\n        # ymax \u2510\n        #      \u2502\n        #      \u2502\n        # ymin \u2518\n        # Parameters\n        # ----------\n        # plot_axis : matplotlib.axes.Axes\n        #     Main plot axis.\n        # y_ax : matplotlib.axes.Axes\n        #     Axis to use to plot the scale\n        # \"\"\"\n\n        if (\n            \"show_data_range\" in self.properties\n            and self.properties[\"show_data_range\"] == \"no\"\n        ):\n            return\n\n        def value_to_str(value):\n            if value % 1 == 0:\n                return str(int(value))\n            else:\n                return f\"{value:.4f}\" if value &lt; 0.01 else f\"{value:.2f}\"\n\n        ymin, ymax = plot_axis.get_ylim()\n\n        ymax_str = value_to_str(ymax)\n        ymin_str = value_to_str(ymin)\n        x_pos = [0, 0.5, 0.5, 0]\n        y_pos = [0.01, 0.01, 0.99, 0.99]\n        y_ax.plot(x_pos, y_pos, color=\"black\", linewidth=1, transform=y_ax.transAxes)\n        y_ax.text(\n            -0.2,\n            -0.01,\n            ymin_str,\n            verticalalignment=\"bottom\",\n            horizontalalignment=\"right\",\n            transform=y_ax.transAxes,\n        )\n        y_ax.text(\n            -0.2,\n            1,\n            ymax_str,\n            verticalalignment=\"top\",\n            horizontalalignment=\"right\",\n            transform=y_ax.transAxes,\n        )\n        y_ax.patch.set_visible(False)\n\n    def plot_text_range(self, ax, ymin, ymax, gr: cb.GenomeRange):\n        ydelta = ymax - ymin\n\n        # set min max\n        def format_lim(lim):\n            return int(lim) if float(lim) % 1 == 0 else f\"{lim:.2f}\"\n\n        ymax_print = format_lim(ymax)\n        ymin_print = format_lim(ymin)\n        small_x = 0.01 * gr.length\n        # by default show the data range\n        ax.text(\n            gr.start - small_x,\n            ymax - ydelta * 0.2,\n            f\"[ {ymin_print} ~ {ymax_print} ]\",\n            horizontalalignment=\"left\",\n            verticalalignment=\"top\",\n        )\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BigwigFragmentCollectionOverlay","title":"<code>BigwigFragmentCollectionOverlay</code>","text":"<p>               Bases: <code>Track</code></p> <p>Overlay multiple bigwig collections on top of each other.</p> <p>Parameters:</p> Name Type Description Default <code>collections</code> <code>List[FragmentBigwigCollection]</code> <p>List of FragmentBigwigCollection objects</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BigwigFragmentCollectionOverlay(Track):\n    \"\"\"\n    Overlay multiple bigwig collections on top of each other.\n\n    Args:\n        collections (List[FragmentBigwigCollection]): List of FragmentBigwigCollection objects\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(self, collections: List[BigwigFragmentCollection], **kwargs):\n        # Initialization\n        self.collections = collections\n\n        for track in self.collections:\n            track.properties[\"show_data_range\"] = \"no\"\n            track.properties[\"data_range_style\"] = \"no\"\n            track.properties[\"label_on_track\"] = \"no\"\n            track.properties[\"is_subtrack\"] = True\n\n        self.properties = {\"collections\": collections}\n        self.properties.update(kwargs)\n\n    @property\n    def subtracks(self):\n        return self.collections\n\n    def plot(self, ax, genome_range, **kwargs):\n        # Method for plot the track\n        # within the genome range \"chrom:start-end\". `genome_range` is a `GenomeRange` object with properties: chrom, start, end\n        # Draw in the pass-in `ax` Axes\n        for collection in self.collections:\n            collection.plot(ax, genome_range, **kwargs)\n\n        self.plot_label()\n\n    def fetch_data(self, genome_range, **kwargs):\n        # Method for fetch the data within genome_range\n        # genome_range is a `coolbox.utilities.GenomeRange` object\n        for collection in self.collections:\n            collection.fetch_data(genome_range, **kwargs)\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BigwigOverlay","title":"<code>BigwigOverlay</code>","text":"<p>               Bases: <code>Track</code></p> <p>Overlay multiple bigwig files on top of each other.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>List[PathLike]</code> <p>List of paths to the bigwig files</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BigwigOverlay(Track):\n    \"\"\"\n    Overlay multiple bigwig files on top of each other.\n\n    Args:\n        files (List[os.PathLike]): List of paths to the bigwig files\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(self, collection: List[Union[cb.BigWig, str]], **kwargs):\n        _collection = []\n        for obj in collection:\n            if isinstance(obj, str):\n                assert os.path.exists(obj) or kwargs.get(\n                    \"ignore_file_validation\"\n                ), f\"File {obj} does not exist\"\n                _collection.append(cb.BigWig(obj))\n            elif isinstance(obj, cb.Track):\n                _collection.append(obj)\n            else:\n                raise ValueError(\n                    f\"Object {obj} is not a valid BigWig or path to a BigWig file\"\n                )\n\n        self.coverages = []\n        self.collection = _collection\n        self.properties = dict()\n        self.properties.update(\n            {\n                \"min_value\": \"auto\",\n                \"max_value\": \"auto\",\n                \"scale\": False,\n                \"scale_n_cis\": False,\n            }\n        )\n        self.properties.update(kwargs)\n        self.properties[\"name\"] = f\"BigWigOverlay.{self.properties.get('title')}\"\n\n    @property\n    def subtracks(self):\n        return self.collection\n\n    def fetch_data(\n        self, gr: GenomeRange, scale: bool = False, scale_n_cis: bool = False, **kwargs\n    ):\n        data = []\n\n        if not scale:\n            for bw in self.collection:\n                data.append(bw.fetch_data(gr, **kwargs))\n\n        elif scale and not scale_n_cis:\n            scaler = Scaler(tracks=self.collection, gr=gr)\n            scaling_factors = scaler.scaling_factors\n\n            for bw, scaling_factor in zip(self.collection, scaling_factors):\n                data.append(bw.fetch_data(gr, **kwargs) / scaling_factor)\n\n        elif scale and scale_n_cis:\n            import pyBigWig\n\n            chrom = gr.chrom\n            if isinstance(self.collection[0], cb.BigWig):\n                bw_file = self.collection[0].properties[\"file\"]\n            else:\n                bw_file = self.collection[0]\n\n            with pyBigWig.open(bw_file) as bw:\n                chrom_length = bw.chroms()[chrom]\n\n            gr_chrom = GenomeRange(chrom, 0, chrom_length)\n            scaler = Scaler(tracks=self.collection, gr=gr_chrom, method=\"total\")\n            scaling_factors = scaler.scaling_factors\n\n            for bw, scaling_factor in zip(self.collection, scaling_factors):\n                data.append(bw.fetch_data(gr, **kwargs) / scaling_factor)\n\n        return data\n\n    def _get_scaling_factors(\n        self, gr: GenomeRange, method: Literal[\"n_cis\", \"mean\", \"max\", \"min\"]\n    ):\n        if method == \"n_cis\":\n            import pyBigWig\n\n            chrom = gr.chrom\n            if isinstance(self.collection[0], cb.BigWig):\n                bw_file = self.collection[0].properties[\"file\"]\n            else:\n                bw_file = self.collection[0]\n\n            with pyBigWig.open(bw_file) as bw:\n                chrom_length = bw.chroms()[chrom]\n\n            gr_chrom = GenomeRange(chrom, 0, chrom_length)\n            scaler = Scaler(tracks=self.collection, gr=gr_chrom, method=\"total\")\n            scaling_factors = scaler.scaling_factors\n        else:\n            scaler = Scaler(tracks=self.collection, gr=gr, method=method)\n            scaling_factors = scaler.scaling_factors\n\n        return scaling_factors\n\n    def plot(self, ax, gr: GenomeRange, **kwargs):\n        scaler = Autoscaler(tracks=self.collection, gr=gr)\n        min_value = (\n            scaler.min_value\n            if self.properties.get(\"min_value\") == \"auto\"\n            else self.properties.get(\"min_value\", 0)\n        )\n        max_value = (\n            scaler.max_value\n            if self.properties.get(\"max_value\") == \"auto\"\n            else self.properties.get(\"max_value\")\n        )\n\n        if self.properties.get(\"scale_method\"):\n            scaling_factors = self._get_scaling_factors(\n                gr, self.properties.get(\"scale_method\")\n            )\n            for ii, (bw, scaling_factor) in enumerate(\n                zip(self.collection, scaling_factors)\n            ):\n                bw.properties[\"min_value\"] = min_value\n                bw.properties[\"max_value\"] = max_value\n                bw.properties[\"show_data_range\"] = \"no\"\n                bw.properties[\"data_range_style\"] = \"no\"\n                bw.properties[\"scaling_factor\"] = scaling_factor\n                plot_bigwig_scaled(bw, ax, gr, scaling_factor, **kwargs)\n\n        else:\n            for ii, bw in enumerate(self.collection):\n                bw.properties[\"show_data_range\"] = \"no\"\n                bw.properties[\"data_range_style\"] = \"no\"\n                bw.properties[\"min_value\"] = min_value\n                bw.properties[\"max_value\"] = max_value\n                bw.properties[\"is_subtrack\"] = True\n                bw.plot(\n                    ax,\n                    gr,\n                    show_data_range=False,\n                    **kwargs,\n                )\n\n        self._plot_text_range(ax, min_value, max_value, gr)\n        self.plot_label()\n\n    def _plot_text_range(self, ax, ymin, ymax, gr: cb.GenomeRange):\n        plot_text_range(self, ax, ymin, ymax, gr)\n\n    def plot_label(self):\n        if self.properties.get(\"label_on_track\") not in [\n            \"True\",\n            \"yes\",\n            \"T\",\n            \"Y\",\n            \"1\",\n            True,\n            1,\n        ]:\n            if (\n                hasattr(self, \"label_ax\")\n                and self.label_ax is not None\n                and \"title\" in self.properties\n            ):\n                self.label_ax.text(\n                    0.15,\n                    0.5,\n                    self.properties[\"title\"],\n                    horizontalalignment=\"left\",\n                    size=\"large\",\n                    verticalalignment=\"center\",\n                )\n            elif hasattr(self, \"label_ax\") and self.properties.get(\"label_subtracks\"):\n                # Plot a patch with the color of the subtracks and the name of the subtrack\n                for i, bw in enumerate(self.collection):\n                    self.label_ax.add_patch(\n                        Polygon(\n                            [\n                                (0.1, 0.5 - (i * 0.1)),\n                                (0.1, 0.6 - (i * 0.1)),\n                                (0.2, 0.6 - (i * 0.1)),\n                                (0.2, 0.5 - (i * 0.1)),\n                            ],\n                            color=bw.properties.get(\"color\", \"black\"),\n                        )\n                    )\n\n                    self.label_ax.text(\n                        0.25,\n                        0.55 - (i * 0.1),\n                        bw.properties.get(\"title\", f\"Subtrack {i}\"),\n                        horizontalalignment=\"left\",\n                        verticalalignment=\"center\",\n                    )\n\n    def adjust_plot(self, ax, gr: GenomeRange):\n        ax.set_xlim(gr.start, gr.end)\n        ymin, ymax = ax.get_ylim()\n        if \"max_value\" in self.properties and self.properties[\"max_value\"] != \"auto\":\n            ymax = self.properties[\"max_value\"]\n        if \"min_value\" in self.properties and self.properties[\"min_value\"] != \"auto\":\n            ymin = self.properties[\"min_value\"]\n\n        if (\n            \"orientation\" in self.properties\n            and self.properties[\"orientation\"] == \"inverted\"\n        ):\n            ax.set_ylim(ymax, ymin)\n        else:\n            ax.set_ylim(ymin, ymax)\n        return ymin, ymax\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.BigwigSubtraction","title":"<code>BigwigSubtraction</code>","text":"<p>               Bases: <code>BigWig</code></p> <p>Compare two bigwig files by plotting their difference.</p> <p>Parameters:</p> Name Type Description Default <code>file1</code> <code>PathLike</code> <p>Path to the first bigwig file</p> required <code>file2</code> <code>PathLike</code> <p>Path to the second bigwig file</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class BigwigSubtraction(cb.BigWig):\n    \"\"\"\n    Compare two bigwig files by plotting their difference.\n\n    Args:\n        file1 (os.PathLike): Path to the first bigwig file\n        file2 (os.PathLike): Path to the second bigwig file\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(self, files: List[str], **kwargs):\n        self.properties = dict()\n        self.properties.update(kwargs)\n        self.properties[\"name\"] = f\"BigWigSubtraction.{self.properties.get('title')}\"\n        super(BigwigSubtraction, self).__init__(files[0], **self.properties)\n\n        self.bw1 = cb.BigWig(files[0])\n        self.bw2 = cb.BigWig(files[1])\n\n    @property\n    def subtracks(self):\n        return [self.bw1, self.bw2]\n\n    def fetch_data(self, gr: GenomeRange, **kwargs):\n        data1 = self.bw1.fetch_data(gr, **kwargs)\n        data2 = self.bw2.fetch_data(gr, **kwargs)\n\n        n_bins = len(range(gr.start, gr.end, self.properties.get(\"binsize\", 10)))\n        new_starts = np.linspace(gr.start, gr.end, n_bins)\n        interpol_1 = np.interp(new_starts, data1.start, data1.score.values)\n        interpol_2 = np.interp(new_starts, data2.start, data2.score.values)\n        diff = interpol_1 - interpol_2\n\n        return pd.DataFrame(\n            {\n                \"chrom\": gr.chrom,\n                \"start\": new_starts,\n                \"end\": pd.Series(new_starts).shift(-1),\n                \"score\": diff,\n            }\n        ).dropna()\n\n    def fetch_plot_data(self, gr: GenomeRange, **kwargs):\n        return self.fetch_data(gr, **kwargs)\n\n    def plot(self, ax, gr: GenomeRange, **kwargs):\n        if not self.properties[\"style\"] == \"line\":\n            super(BigwigSubtraction, self).plot(ax, gr, **kwargs)\n        else:\n            data = self.fetch_data(gr, **kwargs)\n\n            # Split the data into positive and negative values\n            fmt = self.properties.get(\"fmt\")\n            line_width = self.properties.get(\"line_width\", 1)\n            color = self.properties.get(\"color\", \"black\")\n            alpha = self.properties.get(\"alpha\", 1.0)\n            threshold = float(self.properties.get(\"threshold\", 0))\n            threshold_color = self.properties.get(\"threshold_color\")\n\n            num_bins = self.properties.get(\"num_bins\", 700)\n            x = np.linspace(gr.start, gr.end, num_bins)\n            y = np.interp(x, data[\"start\"], data[\"score\"])\n\n            y_pos = y[y &gt; threshold]\n            y_neg = y[y &lt; threshold]\n            x_pos = x[y &gt; threshold]\n            x_neg = x[y &lt; threshold]\n\n            # PLot the positive values as a line\n            ax.plot(\n                x_pos,\n                y_pos,\n                color=color,\n                zorder=1,\n                alpha=alpha,\n                linewidth=line_width,\n                linestyle=fmt,\n            )\n\n            # Plot the negative values as a line\n            ax.plot(\n                x_neg,\n                y_neg,\n                color=threshold_color,\n                zorder=1,\n                alpha=alpha,\n                linewidth=line_width,\n                linestyle=fmt,\n            )\n            ymin, ymax = self.adjust_plot(ax, gr)\n            # disable plot data range in coverage mode\n            if (\n                self.properties[\"data_range_style\"] != \"no\"\n                and \"track\" not in self.__dict__\n            ):\n                self.plot_data_range(\n                    ax, ymin, ymax, self.properties[\"data_range_style\"], gr\n                )\n\n            self.plot_label()\n\n    def plot_label(self):\n        if hasattr(self, \"label_ax\") and self.label_ax is not None:\n            self.label_ax.text(\n                0.15,\n                0.5,\n                self.properties[\"title\"],\n                horizontalalignment=\"left\",\n                size=\"large\",\n                verticalalignment=\"center\",\n            )\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.GenomicAxis","title":"<code>GenomicAxis</code>","text":"<p>               Bases: <code>XAxis</code></p> <p>A genomic axis that shows the genomic coordinates of the region.</p> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class GenomicAxis(cb.XAxis):\n    \"\"\"\n    A genomic axis that shows the genomic coordinates of the region.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super(GenomicAxis, self).__init__()\n        self.properties.update(kwargs)\n\n    def plot(self, ax, gr: GenomeRange, **kwargs):\n        self.ax = ax\n\n        ax.set_xlim(gr.start, gr.end)\n        ticks = np.linspace(gr.start, gr.end, 10)\n        labels = [f\"{x:,.0f}\" for x in ticks]\n\n        ax.axis[\"x\"] = ax.new_floating_axis(0, 0.5)\n        ax.axis[\"x\"].axis.set_ticks(ticks)\n        ax.axis[\"x\"].axis.set_ticklabels(labels)\n        ax.axis[\"x\"].axis.set_tick_params(which=\"minor\", bottom=\"on\")\n\n        ax.axis[\"x\"].major_ticklabels.set(size=10)\n\n        if \"where\" in self.properties and self.properties[\"where\"] == \"top\":\n            ax.axis[\"x\"].set_axis_direction(\"top\")\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.HighlightsFromFile","title":"<code>HighlightsFromFile</code>","text":"<p>               Bases: <code>HighLightsFromFile</code></p> <p>Plot highlights from a bed file. This is a modified version of the HighlightsFromFile class that does not print block of highlights but instead highlights the entire region.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Path to the bed file</p> required <code>**kwargs</code> <p>Additional arguments to pass to the track</p> required Source code in <code>plotnado/api/tracks.py</code> <pre><code>class HighlightsFromFile(cb.HighLightsFromFile):\n    \"\"\"\n    Plot highlights from a bed file.\n    This is a modified version of the HighlightsFromFile class that does not print block of highlights but instead highlights the entire region.\n\n    Args:\n        file (os.PathLike): Path to the bed file\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def plot(self, ax, gr: cb.GenomeRange, **kwargs):\n        from matplotlib.patches import Rectangle\n\n        regions = self.fetch_data(gr, **kwargs)\n\n        for start, end, color in regions:\n            if self.properties[\"color\"] != \"bed_rgb\":\n                color = self.properties[\"color\"]\n\n            ymin, ymax = ax.get_ylim()\n\n            # Add a small offset to the y-axis to avoid the highlights overlapping with the axis\n            # ymin += 0.001 * (ymax - ymin)\n            # ymax -= 0.001 * (ymax - ymin)\n\n            ax.add_patch(\n                Rectangle(\n                    (start, ymin),\n                    end - start,\n                    ymax - ymin,\n                    color=color,\n                    alpha=self.properties[\"alpha\"],\n                    linewidth=0,\n                )\n            )\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.MatrixCapcruncher","title":"<code>MatrixCapcruncher</code>","text":"<p>               Bases: <code>Cool</code></p> <p>Matrix track designed to plot CapCruncher derived matrices.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>PathLike</code> <p>Path to the cooler file</p> required <code>binsize</code> <code>int</code> <p>Binsize of the matrix. Defaults to 5000.</p> required <code>viewpoint</code> <code>str</code> <p>Viewpoint to plot the matrix from</p> required <code>remove_viewpoint</code> <code>bool</code> <p>Remove the viewpoint from the matrix. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class MatrixCapcruncher(cb.Cool):\n    \"\"\"\n    Matrix track designed to plot CapCruncher derived matrices.\n\n    Args:\n        file (os.PathLike): Path to the cooler file\n        binsize (int, optional): Binsize of the matrix. Defaults to 5000.\n        viewpoint (str): Viewpoint to plot the matrix from\n        remove_viewpoint (bool, optional): Remove the viewpoint from the matrix. Defaults to False.\n        **kwargs: Additional arguments to pass to the track\n    \"\"\"\n\n    def __init__(\n        self,\n        file: os.PathLike,\n        binsize: 5000,\n        viewpoint: str,\n        remove_viewpoint=False,\n        **kwargs,\n    ):\n        self.binsize = binsize\n        self.viewpoint = viewpoint\n        self.remove_viewpoint = remove_viewpoint\n        self.properties = dict()\n        self.properties.update(kwargs)\n        self.properties[\"name\"] = f\"CCMatrix.{self.properties.get('title')}\"\n        super(MatrixCapcruncher, self).__init__(file, **kwargs)\n        # Need to override the coolbox default if we need a cmap to be set\n        self.properties[\"color\"] = kwargs.get(\"color\", self.properties[\"color\"])\n\n        # Override the defaults\n        self.properties[\"balance\"] = \"no\"\n\n        if not self._cooler_store_has_binsize:\n            raise ValueError(\n                f\"Viewpoint {viewpoint} or resolution {binsize} not found in supplied file.\"\n            )\n\n        self.cooler = cooler.Cooler(f\"{file}::{viewpoint}/resolutions/{binsize}\")\n        self.capture_bins = self.cooler.info[\"metadata\"][\"viewpoint_bins\"]\n\n    def _cooler_store_has_binsize(self):\n        clrs = cooler.fileops.list_coolers(self.file)\n        expected_path = f\"{self.viewpoint}/resolutions/{self.binsize}\"\n\n        if expected_path in clrs:\n            return True\n\n    def get_matrix(self, coordinates, field=\"count\"):\n        matrix = self.cooler.matrix(field=field, balance=False).fetch(coordinates)\n\n        offset = self.cooler.offset(coordinates)\n        capture_bins = [(bin - offset) for bin in self.capture_bins]\n\n        if self.remove_viewpoint:\n            matrix[capture_bins, :] = 0\n            matrix[:, capture_bins] = 0\n\n        return matrix\n\n    def get_matrix_normalised(\n        self, coordinates, normalization_method=None, **normalisation_kwargs\n    ):\n        methods_stored = {\n            \"n_interactions\": \"count_n_interactions_norm\",\n            \"n_rf_n_interactions\": \"count_n_rf_n_interactions_norm\",\n        }\n\n        if normalization_method == \"raw\":\n            matrix_normalised = self.get_matrix(coordinates)\n\n        elif normalization_method in methods_stored:\n            matrix_normalised = self.get_matrix(\n                coordinates, field=methods_stored[normalization_method]\n            )\n\n        elif normalization_method == \"ice\":\n            import iced\n\n            matrix = self.get_matrix(coordinates)\n            matrix = np.nan_to_num(matrix)\n            # matrix = iced.filter.filter_low_counts(matrix, percentage=0.04)\n            matrix_normalised = iced.normalization.ICE_normalization(\n                matrix, **normalisation_kwargs\n            )  # Get iced matrix\n\n        elif normalization_method == \"icen_cis\":\n            import iced\n\n            matrix = self.get_matrix(coordinates)\n            matrix = np.nan_to_num(matrix)\n            matrix_ice = iced.normalization.ICE_normalization(\n                matrix, **normalisation_kwargs\n            )  # Get iced matrix\n            matrix_normalised = (\n                matrix_ice\n                / int(self.cooler.info[\"metadata\"][\"n_cis_interactions\"])\n                * 1e6\n            )  # Correct for number of interactions * 1e6\n\n        elif normalization_method == \"icen_scale\":\n            matrix = self.get_matrix(coordinates)\n            matrix = np.nan_to_num(matrix)\n            matrix_ice = iced.normalization.ICE_normalization(\n                matrix, **normalisation_kwargs\n            )  # Get iced matrix\n            matrix_normalised = matrix_ice / self.properties[\"scaling_factor\"]\n\n        else:\n            raise ValueError(\n                f'Incorrect normalisation specified choose from: {\" \".join([\"raw\", *methods_stored.keys(),\"ice\", \"icen_cis\", \"icen_scale\"])}'\n            )\n\n        return matrix_normalised\n\n    def fetch_data(\n        self, gr: cb.GenomeRange, gr2: cb.GenomeRange = None, **kwargs\n    ) -&gt; np.ndarray:\n        norm = self.properties.get(\"normalization\", \"raw\")\n        matrix = self.get_matrix_normalised(\n            f\"{gr.chrom}:{gr.start}-{gr.end}\", normalization_method=norm, **kwargs\n        )\n        return self.fill_zero_nan(matrix)\n\n    def plot_matrix(self, gr: GenomeRange, gr2: GenomeRange = None):\n        # Code taken and adapted from coolbox\n        gr = GenomeRange(gr)\n\n        if \"JuiceBox\" in self.properties[\"color\"]:\n            cmap = MatrixCapcruncher.get_juicebox_cmaps()[self.properties[\"color\"]]\n        else:\n            cmap = cm.get_cmap(self.properties[\"color\"])\n\n        lowest = cmap(0)\n        cmap.set_bad(lowest)\n        cmap.set_under(lowest)\n\n        ax = self.ax\n        arr = self.matrix\n        c_min, c_max = self.matrix_val_range\n\n        if self.properties[\"max_value\"] == \"auto\":\n            matrix_triu = np.triu(self.matrix)\n            c_max = np.percentile(matrix_triu, 98)\n\n        if gr2 is None and self.style == self.STYLE_TRIANGULAR:\n            # triangular style\n            scale_r = 1 / math.sqrt(2)\n            r_len = gr.end - gr.start\n            # Rotate image using Affine2D, reference:\n            #     https://stackoverflow.com/a/50920567/8500469\n\n            tr = (\n                transforms.Affine2D()\n                .translate(-gr.start, -gr.start)\n                .rotate_deg_around(0, 0, 45)\n                .scale(scale_r)\n                .translate(gr.start + r_len / 2, -r_len / 2)\n            )\n\n            img = ax.matshow(\n                arr,\n                cmap=cmap,\n                transform=tr + ax.transData,\n                extent=(gr.start, gr.end, gr.start, gr.end),\n                aspect=\"auto\",\n                interpolation=\"none\",\n            )\n\n        elif gr2 is None and self.style == self.STYLE_WINDOW:\n            # window style\n            # exist in HicMatBase\n            fgr = self.fetched_gr\n            scale_factor = fgr.length / gr.length\n            scale_r = scale_factor / math.sqrt(2)\n            length_dialog = gr.length * scale_factor\n            delta_x = length_dialog * (gr.start - fgr.start) / fgr.length\n            delta_x = length_dialog / 2 - delta_x\n            tr = (\n                transforms.Affine2D()\n                .translate(-gr.start, -gr.start)\n                .rotate_deg_around(0, 0, 45)\n                .scale(scale_r)\n                .translate(gr.start + delta_x, -fgr.length / 2)\n            )\n            img = ax.matshow(\n                arr,\n                cmap=cmap,\n                transform=tr + ax.transData,\n                extent=(gr.start, gr.end, gr.start, gr.end),\n                aspect=\"auto\",\n            )\n        else:\n            if gr2 is None:\n                gr2 = gr\n            # matrix style\n            img = ax.matshow(\n                arr,\n                cmap=cmap,\n                extent=(gr.start, gr.end, gr2.end, gr2.start),\n                aspect=\"auto\",\n            )\n\n        if self.norm == \"log\":\n            img.set_norm(colors.LogNorm(vmin=c_min, vmax=c_max))\n        else:\n            img.set_norm(colors.Normalize(vmin=c_min, vmax=c_max))\n\n        return img\n\n    @staticmethod\n    def get_juicebox_cmaps():\n        JuiceBoxLikeColor = LinearSegmentedColormap.from_list(\n            \"interaction\", [\"#FFFFFF\", \"#FFDFDF\", \"#FF7575\", \"#FF2626\", \"#F70000\"]\n        )\n        JuiceBoxLikeColor.set_bad(\"white\")\n        JuiceBoxLikeColor.set_under(\"white\")\n        JuiceBoxLikeColor2 = LinearSegmentedColormap.from_list(\n            \"interaction\", [\"#FFFFFF\", \"#FFDFAF\", \"#FF7555\", \"#FF2600\", \"#F70000\"]\n        )\n        JuiceBoxLikeColor2.set_bad(\"white\")\n        JuiceBoxLikeColor2.set_under(\"white\")\n\n        return {\n            \"JuiceBoxLike\": JuiceBoxLikeColor,\n            \"JuiceBoxLike2\": JuiceBoxLikeColor2,\n        }\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.MatrixCapcruncherAverage","title":"<code>MatrixCapcruncherAverage</code>","text":"<p>               Bases: <code>MatrixCapcruncher</code></p> <p>A matrix track that averages multiple matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matricies</code> <code>List[MatrixCapcruncher]</code> <p>List of MatrixCapcruncher objects</p> required <code>aggregation</code> <code>str</code> <p>Aggregation method. Defaults to \"mean\". Choices are \"sum\", \"mean\", \"median\".</p> <code>'mean'</code> <code>**kwargs</code> <p>Additional arguments to pass to the track</p> <code>{}</code> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class MatrixCapcruncherAverage(MatrixCapcruncher):\n    \"\"\"\n    A matrix track that averages multiple matrices.\n\n    Args:\n        matricies (List[MatrixCapcruncher]): List of MatrixCapcruncher objects\n        aggregation (str, optional): Aggregation method. Defaults to \"mean\". Choices are \"sum\", \"mean\", \"median\".\n        **kwargs: Additional arguments to pass to the track\n\n    \"\"\"\n\n    def __init__(\n        self,\n        matricies: List[MatrixCapcruncher],\n        aggregation: Literal[\"sum\", \"mean\", \"median\"] = \"mean\",\n        **kwargs,\n    ):\n        self.matricies = matricies\n        self.aggregation = aggregation\n        self.properties = matricies[0].properties\n        self.properties.update(kwargs)\n        self.properties[\"name\"] = f\"CCMatrix.{self.properties.get('title')}\"\n\n        # Need to override the coolbox default if we need a cmap to be set\n        self.properties[\"color\"] = kwargs.get(\"color\", self.properties[\"color\"])\n\n        # Override the defaults\n        self.properties[\"balance\"] = \"no\"\n\n    @property\n    def subtracks(self):\n        return self.matricies\n\n    @functools.cache\n    def fetch_data(self, gr: cb.GenomeRange, gr2=None, **kwargs):\n        data = []\n        for matrix in tqdm.tqdm(self.matricies):\n            data.append(matrix.fetch_data(gr, **kwargs))\n\n        try:\n            func_agg = getattr(np, self.aggregation)\n        except AttributeError:\n            raise ValueError(\n                f\"Aggregation function {self.aggregation} not found in numpy\"\n            )\n\n        # Aggregate the list of matricies into a single matrix\n        data = func_agg(data, axis=0)\n\n        self.fetched_gr = gr\n        self.fetched_gr2 = gr2\n        return data\n\n    def plot(self, ax, gr: GenomeRange, **kwargs):\n        self.ax = ax\n        # fetch processed plot_data\n        self.matrix = self.fetch_data(gr, **kwargs)\n        # plot matrix\n        img = self.plot_matrix(gr, kwargs.get(\"gr2\"))\n        self.adjust_figure(gr, kwargs.get(\"gr2\"))\n        self.draw_colorbar(img)\n        self.plot_label()\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.ScaleBar","title":"<code>ScaleBar</code>","text":"<p>               Bases: <code>Track</code></p> <p>A scale bar that shows the length of the genomic region.</p> Source code in <code>plotnado/api/tracks.py</code> <pre><code>class ScaleBar(Track):\n    \"\"\"\n    A scale bar that shows the length of the genomic region.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        self.properties = dict()\n        self.properties[\"name\"] = \"Scale\"\n        self.properties.update(kwargs)\n        super(ScaleBar, self).__init__()\n\n    def fetch_data(self, **kwargs):\n        pass\n\n    def get_appropriate_scale(self, length):\n        if length &lt;= 1e3:\n            scale = 1e2\n        elif 1e3 &lt; length &lt; 1e4:\n            scale = 1e3\n        elif 1e4 &lt; length &lt; 1e5:\n            scale = 1e4\n        elif 1e5 &lt; length &lt; 1e6:\n            scale = 1e5\n        elif 1e6 &lt; length &lt; 1e7:\n            scale = 1e6\n        elif 1e7 &lt; length &lt; 1e8:\n            scale = 1e8\n\n        return scale\n\n    def plot(self, ax, gr, **kwargs):\n        position = self.properties.get(\"position\", \"left\")\n        y_midpoint = 0.5\n\n        if self.properties.get(\"scale_distance\"):\n            scale_distance = self.properties[\"scale_distance\"]\n\n        else:\n            scale_distance = self.get_appropriate_scale(gr.end - gr.start)\n\n        # Determine x start and end based on position\n        if position == \"left\":\n            x0 = gr.start\n            x1 = x0 + scale_distance\n        elif position == \"right\":\n            x0 = gr.end - scale_distance\n            x1 = gr.end\n        else:\n            raise ValueError('Position can only be \"left\" or \"right\"')\n\n        # Plot scale bar\n        ax.plot([x0, x1], [y_midpoint, y_midpoint], color=\"black\")\n        ax.plot([x0, x0], [y_midpoint - 0.1, y_midpoint + 0.1], color=\"black\", lw=1)\n        ax.plot([x1, x1], [y_midpoint - 0.1, y_midpoint + 0.1], color=\"black\", lw=1)\n\n        scale_distance_human_readable = get_human_readable_number_of_bp(scale_distance)\n\n        ax.text(\n            (x0 + (scale_distance / 2)),\n            y_midpoint - 0.2,\n            scale_distance_human_readable,\n            ha=\"center\",\n            va=\"center\",\n        )\n\n        ax.set_xlim(gr.start, gr.end)\n        ax.set_ylim(0, 1)\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.Scaler","title":"<code>Scaler</code>","text":"Source code in <code>plotnado/api/tracks.py</code> <pre><code>class Scaler:\n    def __init__(\n        self,\n        tracks: List[cb.Track],\n        gr: cb.GenomeRange,\n        gr2: cb.GenomeRange = None,\n        method: Literal[\"max\", \"mean\", \"total\"] = \"mean\",\n    ):\n        self.tracks = tracks\n        self.gr = gr\n        self.gr2 = gr2\n        self.method = method\n\n        from .track_wrapper import MATRIX_TRACKS, BIGWIG_TRACKS, TrackWrapper\n\n        assert len(tracks) &gt; 0, \"No tracks to autoscale\"\n        assert all(\n            isinstance(t, (cb.Track, TrackWrapper)) for t in tracks\n        ), \"All tracks must be of type cb.Track\"\n        assert all(\n            type(t) in MATRIX_TRACKS + BIGWIG_TRACKS for t in tracks\n        ), \"All tracks must be of tracks that produce numerical data (MatrixCapcruncher, BigWig, etc)\"\n\n    @property\n    def data(self) -&gt; List[np.ndarray]:\n        \"\"\"\n        Get the data from all tracks for the specified region\n        \"\"\"\n        _data = [t.fetch_data(gr=self.gr, gr2=self.gr2) for t in self.tracks]\n\n        if isinstance(\n            _data[0], pd.DataFrame\n        ):  # If the data is a DataFrame, we need to extract the values from the last column\n            _data = [d.values[:, -1] for d in _data]\n        elif isinstance(_data[0], np.ndarray):\n            pass\n\n        return _data\n\n    @property\n    def scaling_factors(self) -&gt; np.ndarray:\n        if self.method == \"max\":\n            arr = [np.nanmax(d, axis=0) for d in self.data]\n        elif self.method == \"mean\":\n            arr = [np.nanmean(d, axis=0) for d in self.data]\n        elif self.method == \"total\":\n            arr = [np.nansum(d, axis=0) for d in self.data]\n\n        return np.array(arr) / np.max(arr)\n</code></pre>"},{"location":"reference/plotnado/api/tracks/#plotnado.api.tracks.Scaler.data","title":"<code>data</code>  <code>property</code>","text":"<p>Get the data from all tracks for the specified region</p>"},{"location":"reference/plotnado/api/utils/","title":"Utils","text":""},{"location":"reference/plotnado/api/utils/#plotnado.api.utils.get_human_readable_number_of_bp","title":"<code>get_human_readable_number_of_bp(bp)</code>","text":"<p>Converts integer into human readable basepair number</p> Source code in <code>plotnado/api/utils.py</code> <pre><code>def get_human_readable_number_of_bp(bp: int) -&gt; str:\n    \"\"\"Converts integer into human readable basepair number\"\"\"\n\n    if bp &lt; 1000:\n        bp = f\"{bp}bp\"\n    elif (bp / 1e3) &lt; 1000:\n        bp = f\"{bp / 1e3}kb\"\n    elif (bp / 1e6) &lt; 1000:\n        bp = f\"{bp / 1e6}mb\"\n\n    return bp\n</code></pre>"},{"location":"reference/plotnado/api/utils/#plotnado.api.utils.get_max_value_over_region","title":"<code>get_max_value_over_region(bigwigs, region, exclude=None)</code>","text":"<p>Get the maximum value over a region in a list of bigwig files</p> <p>Parameters:</p> Name Type Description Default <code>bigwigs</code> <code>Iterable[Union[Path, str]]</code> <p>List of bigwig files</p> required <code>region</code> <code>GenomeRange</code> <p>Region to get the maximum value over</p> required <code>exclude</code> <code>GenomeRange</code> <p>Region to exclude from the maximum value calculation. Defaults to None.</p> <code>None</code> Source code in <code>plotnado/api/utils.py</code> <pre><code>def get_max_value_over_region(\n    bigwigs: Iterable[Union[pathlib.Path, str]],\n    region: cb.GenomeRange,\n    exclude: cb.GenomeRange = None,\n) -&gt; float:\n    \"\"\"\n    Get the maximum value over a region in a list of bigwig files\n\n    Args:\n        bigwigs (Iterable[Union[pathlib.Path, str]]): List of bigwig files\n        region (cb.GenomeRange): Region to get the maximum value over\n        exclude (cb.GenomeRange, optional): Region to exclude from the maximum value calculation. Defaults to None.\n    \"\"\"\n\n    max_values = []\n    for bw in bigwigs:\n        with pyBigWig.open(str(bw)) as f:\n            chrom_len = f.chroms(region.chrom)\n            start = int(max(0, region.start))\n            end = int(min(region.end, chrom_len))\n\n            if exclude:\n                # Split the region into two parts\n                if start &lt; exclude.start:\n                    start1, end1 = start, exclude.start\n                    start2, end2 = exclude.end, end\n                else:\n                    start1, end1 = exclude.end, end\n                    start2, end2 = start, exclude.start\n\n                max_val1 = f.stats(region.chrom, start1, end1, type=\"max\")[0]\n                max_val2 = f.stats(region.chrom, start2, end2, type=\"max\")[0]\n                max_values.append(max(max_val1, max_val2))\n\n            else:\n                max_val = f.stats(region.chrom, start, end, type=\"max\")[0]\n                max_values.append(max_val)\n\n    return round(max(max_values))\n</code></pre>"},{"location":"reference/plotnado/api/utils/#plotnado.api.utils.interval_to_pyranges","title":"<code>interval_to_pyranges(interval)</code>","text":"<p>Convert a GenomeRange to a PyRanges object</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>GenomeRange</code> <p>GenomeRange to convert</p> required Source code in <code>plotnado/api/utils.py</code> <pre><code>def interval_to_pyranges(interval: cb.GenomeRange) -&gt; pr.PyRanges:\n    \"\"\"\n    Convert a GenomeRange to a PyRanges object\n\n    Args:\n        interval (cb.GenomeRange): GenomeRange to convert\n    \"\"\"\n\n    return pr.PyRanges(\n        {\n            \"Chromosome\": [interval.chrom],\n            \"Start\": [interval.start],\n            \"End\": [interval.end],\n        }\n    )\n</code></pre>"}]}